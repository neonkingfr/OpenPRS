%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -*- Mode: Latex -*- %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% oprs-kernel.tex -- 
%% Copyright (c) 1991-2014 Francois Felix Ingrand.
%% All rights reserved.
%%
%% Redistribution and use in source and binary forms, with or without
%% modification, are permitted provided that the following conditions
%% are met:
%%
%%    - Redistributions of source code must retain the above copyright
%%      notice, this list of conditions and the following disclaimer.
%%    - Redistributions in binary form must reproduce the above
%%      copyright notice, this list of conditions and the following
%%      disclaimer in the documentation and/or other materials provided
%%      with the distribution.
%%
%% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
%% "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
%% LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
%% FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
%% COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
%% INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
%% BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
%% LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
%% CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
%% LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
%% ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
%% POSSIBILITY OF SUCH DAMAGE.
%%
%% $Id$
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\part{\CPK{}}
\node{OPRS Kernel}
\cpindex{OPRS Kernel}



\chapter*{Overview of the \CPK{}}
\node{Overview of the OPRS Kernel}
\cpindex{Overview of the OPRS Kernel}

The \CPK{} is certainly the most important program of the \COPRSDE{}. It is the
program which executes the OPs and the procedures. It is the core of the OPRS
technology. A \CPK{} is composed of:

\begin{itemize}

\item A database containing the facts loaded in the system,

\item A library of plans and procedures describing the conditional
sequences of actions which must be done to achieve specific goals or to react
to particular events,

\item A tasks graph composed of a partial order of the plans chosen for
execution.

\end{itemize}

\COPRS{} is the implementation in C of the OPRS technology. The \COPRS{} main assets
are:

\begin{itemize}

\item advanced language for procedural representation,

\item possibility of redefining the control algorithm of the main loop in
this same language,

\item real-time main loop which guarantees a bound on reaction time,

\item possibility of defining or redefining evaluable predicates,
evaluable functions and actions to suit your application,

\item possibility of tuning the kernel to your application,

\item advanced and non-monotonic use of the database,

\item each \CPK{} is an independent Unix process,

\item available under various Unix (Solaris, Ultrix, Sun OS, etc.) and real-time
Unix system (VxWorks),

\item reduced size of the kernel (few hundreds of kilo bytes), compared
to Lisp and systems developed in Lisp.

\end{itemize}

You can call this program directly from a Unix shell or you can call it
directly from the \OPRSS{} when you execute the \code{make} command.

The \CPK{} is also a ``part'' of the \XOPRS{} program. In fact, the
kernel part of \XOPRS{} is the \CPK{}. In one case, the main loop
runs alone; in the other case, it runs interleaved with the Xt
Application Main Loop. Note that if the \CPK{} is running alone (not in
the Xt Application Main Loop), then the performances are increased. Any
performance study should be made with the kernel alone (except, of course,
if the goal is to evaluate the performance of the X interface).

\chapter{How to Use the \CPK{}}
\node{How to Use the OPRS Kernel}
\cpindex{How to Use the OPRS Kernel}

The \COPRS{} can be called directly from the keyboard or, if you prefer, you can
create, kill or modify a \CPK{} using commands of the \OPRSS{}
(\pxref{Commands of the OPRS-Server}, for details). The \CPK{} can be run
without being connected to the \OPRSS{} but still needs to be connected to
the \MPA{}. Connection to the \MPA{}  is mandatory, but  automatically performed by
the kernel. If there is already a \MPA{} running on the specified host/port,
then  the kernel will connect to it. Otherwise, it will attempt to start one
and then to connect to it.

If you start a \CPK{} from the \OPRSS{}, connections to the \OPRSS{}
are made automatically. However, if you start it from a Unix shell (on another
host for example) then you need to connect it to the \OPRSS{} (unless you
specify the \code{-a} argument). This is done by issuing the \code{accept}
command in the \OPRSS{}.

\section{How to Start a \CPK{}}
\node{How to Start a OPRS Kernel}
\cpindex{How to Start a OPRS Kernel}


You can start a new \CPK{} either by typing the command \code{oprs}
at the Unix prompt:

\code{\% oprs FOO}

This will only work if there is already a \OPRSS{} running, or you will get
this error message:\\* 
\code{``client: connect: Host is unreachable''}.

If there is a \OPRSS{}, you will be reminded to issue the \code{accept}
command in the \OPRSS{} with the following message:\\*
\code{``Go in the oprs-server, and execute the accept command.''}

or you can start a new \CPK{} with the \code{make} command of the \OPRSS{}
(the \code{make\_x} command start a \XPK{} instead):

\code{OPRS-Server> make foo}

Note that if you start \COPRS{} from the Unix shell, you may want to specify a
number of options or arguments, for example, if the \OPRSS{} and the
\MPA{} don't use the default socket port for their socket communication,
then you need to specify in the \code{oprs} command the port number on which
both programs expect connections. Unless you started the kernel with the
\code{-a} argument, you are then required to register this kernel from the
\OPRSS{} with the \code{accept} command.

Upon start-up, and just before entering the \CPK{} main loop, the kernel will
execute the:\\*
\code{start\_kernel\_user\_hook}\\*
function (\pxref{User Hooks}). This function can be used for example to
initialize some data structures, or to install an intention scheduler
(\pxref{Intention Graph Scheduling}). This function is executed before any
loading command specified with the \code{-x} argument.

\section{Arguments to the \protect\code{oprs} Command}
\node{Arguments to the oprs Command}
\cpindex{Arguments to the \protect\code{oprs} Command}
\pgindex{oprs command}

If a \CPK{} is created from the Unix shell, then you can specify a number of
arguments. There is a large number of possible arguments, but most of them are
seldom used.

Usage: 
\begin{verbatim}
oprs [-s server-hostname] [-i server-port-number] [-a]
    [-m message-passer-hostname] [-j message-passer-port-number]
    [-x include-filename]* [-c oprs-command]*
    [-I size-symbol-hash-table] [-P size-pred-hash-table]
    [-D size-database-hash-table] [-F size-function-action-hash-table]
    [-d oprs-data-path] [-p] [-l upper|lower|none] [-L en|fr] [-n] client-name
\end{verbatim}

All the arguments are optional except for the name of the \CPK{}.
It is preferable to use upper case for the name. In fact, the name is upper
casified automatically, unless it is surrounded by \samp{|}.

\begin{description}

\item[\code{-s}] to specify the hostname on which the server is running.  If
the kernel cannot connect to this hostname on the specified port, then the
program exits with an error message.

\item[\code{-i}] to specify the port on which the \OPRSS{} expects a
connection. Do not forget to issue the \code{accept} command in the
\OPRSS{}.

\item[\code{-a}] to specify the kernel should runs alone without being
connected to the \OPRSS{}. In this case you do not need to issue the
\code{accept} command in the \OPRSS{}.

\item[\code{-m}] to specify the hostname on which the \MPA{} runs or will be
started (usually the same hostname as the \OPRSS{}). If the \CPK{}
cannot connect to this hostname on the specified port (even after trying to
start the \MPA{}), then the program exits with an error message.

\item[\code{-j}] to specify the port on which the \MPA{} is expecting a
connection (or will be started if necessary).

\item[\code{-x}] to specify an include file to load upon start-up. This will
  save you a \code{connect} in the \OPRSS{}, followed by an \code{include}
  and a \code{disconnect} in the \CPK{}. Reminder: include files can contain
  other \code{include} directives. This option can appear more than once, in
  which case, files are loaded in the they order are specified.
  
\item[\code{-c}] to specify a command to execute upon start-up. This option
  can appear more than once, in which case, the commands are executed in the
  order they are specified.

\item[\code{-d}] to specify a data path, i.e.\ a colon separated list of
directories where the kernel will look for data files (\file{.inc},
\file{.opf} and \file{.db}) (\pxref{OPRS Kernel Environment Variables}).

\item[\code{-I}] to specify the size of the symbol hash-table (default size:
1024).

\item[\code{-D}] to specify the size of the database main hash-table
(default size: 1024).

\item[\code{-P}] to specify the size of the predicates hash-table
(default size: 64).

\item[\code{-E}] to specify the size of the evaluable functions, actions and
evaluable predicates hash-tables (default size: 128).

\item[\code{-F}] to specify the size of the function/action hash-table
(default size: 64).

\item[\code{-p}] can be used to parse and print the temporal operator in English
instead of the single letter. It will parse and print \code{achieve} instead of \samp{!},
and \code{wait} instead of \samp{\^{}} and so on.  The parser understands both syntaxes,
 but the printer will output the english form.

\item[\code{-l upper|lower|none}] can be used to print and parse all the symbol
and id in upper case, lower case or in no particular case. You may specify this
option by setting the \code{OPRS\_ID\_CASE} environment variable:\\*
Example:
\begin{verbatim}
setenv OPRS_ID_CASE none
\end{verbatim}

\item[\code{-L en|fr}] can be used to select the language of the interface
(French or English). Note that by default your kernel is in English. Note also
that for the applications with an X interface (i.e.\ \XPK{} and the \OPE{} the
choice of the \file{app-defaults} file will select the language
(\pxref{Xt/Motif Widgets Hierarchy and Resources}). In this case, selecting a
different value with the option will lead to a warning and to a mix of language
in the interface.

\item[\code{-n}] can be used to specify the name of the kernel. The \code{-n}
is only required if the name is not the last arguments.

\end{description}

\section{\CPK{} Environment Variables}
\node{OPRS Kernel Environment Variables}
\cpindex{OPRS Kernel Environment Variables}
\cpindex{Environment Variables}

A number of environment variables can be used to customize the
\CPK{} or to define default arguments. Arguments passed using the command line
have precedence on those acquired from environment variables.

\begin{description}

\cpindex{OPRS\_DATA\_PATH}
\item[\code{OPRS\_DATA\_PATH}] is used  to specify a data path, i.e.\ a colon separated
list of directories where the kernel will look for data files (\file{.inc},
\file{.opf} and \file{.db}). It is used by the \CPK{} and the \XPK{}. It is
equivalent to the \code{-d} command line argument.\\*
Example:
\begin{verbatim}
export OPRS_DATA_PATH=./data:/usr/local/share/oprs/data:${HOME}/data
\end{verbatim}


\cpindex{OPRS\_DOC\_DIR}
\item[\code{OPRS\_DOC\_DIR}] is used  to specify the location of the online \COPRSDE{}
documentation. It is used by the \XPK{} and the \OPE{}.
Example:
\begin{verbatim}
export OPRS_DOC_DIR=/usr/local/share/doc/openprs
\end{verbatim}

\cpindex{OPRS\_MP\_PORT}
\item[\code{OPRS\_MP\_PORT}] is used  to specify the port on which the \MPA{} will
listen to connection. It is used by the \CPK{}, the \XPK{}, the \OPRSS{}
and the \MPA{}. It is equivalent to the \code{-j} command line argument. \\*
Example:
\begin{verbatim}
export OPRS_MP_PORT=3456
\end{verbatim}
If the MP Port is not explicitly set, it defaults to 3300.

\cpindex{OPRS\_MP\_HOST}
\item[\code{OPRS\_MP\_HOST}] is used  to specify the host on which the \MPA{} will
listen to connection. It is used by the \CPK{}, the \XPK{}, the \MPA{} and the
\OPRSS{}. It is equivalent to the \code{-m} command line argument.\\*
Example:
\begin{verbatim}
export OPRS_MP_HOST=alf.laas.fr
\end{verbatim}

\cpindex{OPRS\_SERVER\_PORT}
\item[\code{OPRS\_SERVER\_PORT}] is used to specify the port on which the
\OPRSS{} will listen to connection. It is used by the \CPK{}, the \XPK{}
and the \OPRSS{}. It is equivalent to the \code{-i} command line argument.\\*
Example:
\begin{verbatim}
export OPRS_SERVER_PORT=3457
\end{verbatim}

\cpindex{OPRS\_SERVER\_HOST}
\item[\code{OPRS\_SERVER\_HOST}] is used to specify the host on which the
\OPRSS{} will listen to connection. It is used by the \CPK{} and the
\XPK{}. It is equivalent to the \code{-s} command line argument.\\*
Example:
\begin{verbatim}
export OPRS_SERVER_HOST=alf.laas.fr
\end{verbatim}

\cpindex{OPRS\_ID\_CASE}
\item[\code{OPRS\_ID\_CASE}] is used to specify if the program should upper case,
lower case or should not change the case of the parsed Id. This is equivalent
to the \code{-l} option. The possible values
are \code{lower}, \code{upper} or \code{none}:\\*
Example:
\begin{verbatim}
export OPRS_ID_CASE=none
\end{verbatim}

\end{description}

The various \code{\_PORT} and \code{\_HOST} environment variables are very
useful when different users are using the \COPRSDE{} on the same host. By setting
these variables to the proper value, they can make sure that their application
will not interact with each other.

\section{How to Kill an \CPK{}}
\node{How to Kill an OPRS Kernel}
\cpindex{How to Kill an OPRS Kernel}

You can kill a \CPK{} with the \code{kill} command of the
\OPRSS{}:

\code{OPRS-Server> kill foo}

If you kill a \CPK{}that is already dead, you get a warning.

You can also kill a \CPK{} with the \code{quit}, \code{q} or \code{EOF}
commands. In this case, you need to be connected to this \COPRS{} and issue the
command at the prompt:

\code{FOO> quit}

\section{\CPK{} over Network}
\node{OPRS Kernel over Network}
\cpindex{OPRS Kernel over Network}

All the communications between the various components of the \COPRSDE{} are made
using Internet sockets. You can easily
run \aCPK{} on a machine different from the one on which the \OPRSS{}
runs. On machines with notably slow process switching we strongly
advise that you run the \OPRSS{} and the \MPA{} on a host different from the one
upon which the \CPK{} is running. In any case, you can start \aCPK{} from any
host, providing you specify the proper arguments to enable the \CPK{} to
establish connection with the \OPRSS{} and the \MPA{}. Note that you need to
issue an \code{accept} command in the \OPRSS{} to establish the connection.

\section{How to Connect to \aCPK{}}
\node{How to Connect to a OPRS Kernel}
\cpindex{How to Connect to a OPRS Kernel}
\cpindex{Run Mode}
\cpindex{Command Mode}

When you start \aCPK{}, it enters its main loop and is in \dfn{run} mode. In
this mode, the kernel checks for messages from the \MPA{} and commands from the
\OPRSS{}, but does not interact directly with the user. If you want to
interact directly with \aCPK{} (to consult the database, or load some OPs, and
so on), you can do it using the \code{connect} command of the \OPRSS{}. This
will put the kernel in \dfn{command} mode. Note: This is not true for the \XPK{}
with which you can interact using the X/Motif interface.

For example, assuming you have created \aCPK{} named \code{FOO}, you can
connect to it by issuing the following command from the \OPRSS{} window.

\code{OPRS-Server> connect foo}

If the designated kernel has been started from the server, then the prompt
changes from:

\code{ OPRS-Server>}

to:

\code{FOO>}

in the same window or terminal.

If the designated kernel has been started from a Unix shell, then the new prompt
appears in the window or tty where it was started, and the \OPRSS{} is
blocked, waiting until the \CPK{} leaves its \dfn{command} mode.

Note that at this point, the user is connected through the keyboard to the
designated \CPK{}, and everything typed is in fact interpreted by
the \CPK{}. Consequently, the \OPRSS{} is now disconnected from
the keyboard and will wait until the \CPK{} releases it.

One problem with this scheme is that during this time, the \CPK{} is deaf to
the rest of the world. For example, it does not check for messages from the
\MPA{}, and it does not even run its top level loop\dots{} However, the messages
are queued (as much as possible) and the main loop will parse them upon
restart.  In any case, the connection to \aCPK{} should be used as seldom as
possible and the kernel should then be left alone to run its own life.
Nevertheless its use is not prohibited, and is usually appropriate to load
database, or OPs just after the \CPK{} has been started.

To disconnect the user and the keyboard from the \CPK{}, the user can
type:

\code{FOO> disconnect}

The prompt then becomes:

\code{OPRS-Server>}

if the kernel was in the same window, otherwise this prompt appears again
in the window where the \OPRSS{} is running.

You can then interact with the \OPRSS{} again, and the \CPK{} returns in
\dfn{run} mode.

If you happen to break the command parser, you need to reset it. Do this by typing a dot 
\samp{.} at the beginning of a new line, i.e.\ \key{RET},
\key{.}, and \key{RET}. \xref{OPRS Kernel Parser} for more on this subject.

Keep in mind that you do not need to connect to \aCPK{} to execute a command
such as loading a database, or an include file. You can perform all of these
from the \OPRSS{} using the \code{transmit} command (\pxref{OPRS-Server Communication Commands}). The main advantage of the command mode is that the
interaction with the user is direct, but the main advantage of the
\code{transmit} command of the \OPRSS{} is that it does not stop the \CPK{}
main loop, it merely slows it down, as the command will be executed by the main
loop itself.

\chapter{\CPK{} Commands}
\node{OPRS Kernel Commands}
\cpindex{OPRS Kernel Commands}

The \CPK{} has a number of commands which can either be executed by the
user (when he is connected to the \CPK{} of his choice) or put into an
\dfn{include file}. Most commands have self-explanatory names,
however, their syntax is very rigorous and the command parser will detect any
inconsistency. If you put your command in an include file, keep in mind that it
can contain any command except the \code{connect} and \code{disconnect}
commands.

The \CPK{} commands are classified in different categories and are presented
in the following sections. Some commands appear in more than
one category and are presented in each category with the appropriate cross
reference.



\section{\CPK{} Parser}
\node{OPRS Kernel Parser}
\cpindex{OPRS Kernel parser}

The \CPK{} uses a parser to parse the user commands (so does the \OPRSS{}
and to some extent the \OPE{} and the \XPK{}). If for some reason the parser
gets confused, presumably because of a syntax error, you can type a dot at the
beginning of a new line, followed by a carriage return to reset it (i.e.
\key{RET}, \key{.}, and \key{RET}). In any case, when you reset the parser, you
will get the prompt after a warning.

\begin{verbatim}
FOO> echoo (asd)
FOO: warning: syntax error near ECHOO
.
FOO: warning: Parsing error, unknown command, reseting the parser near .

FOO> echo (asd)
( ASD )

FOO>
\end{verbatim}

If you do not get the prompt, it means that the parser is still expecting a
token to parse. (In some very peculiar situations, the parser needs to get a close
parenthesis \samp{)} to accept the reset token \verb+\n.\n+).


\section{\CPK{} Database Commands}
\node{OPRS Kernel Database Commands}
\cpindex{OPRS Kernel Database Commands}

The database commands allow the user to conclude, consult, delete facts, and
modify some properties of the database. These commands are usually used
whenever the user wants to interact directly with the database. However, while
the \CPK{} is running, facts will be concluded/deleted/consulted by the kernel
itself.

\begin{itemize}

\pgindex{delete (oprs)}
\item \code{delete \var{expression}}. Delete the \var{expression}
(\pxref{General Expressions}) from the database. Note that you can delete
expressions containing variables. Variables in this context are universally
quantified, i.e.\ all the matching expressions will be deleted. Note that you
cannot delete gexpressions containing logical operators.\\*
Example: \code{delete (foo a b \$x)}\\*
\code{delete (bar 12.0 (+ 4 5))}

\pgindex{consult (oprs)}
\item \code{consult \var{gexpression}}. Consult the \var{gexpression}
(\pxref{General Expressions}) in the database. Note that the consult
command accepts a gexpression (i.e.\ expression combined with logical
operators), not only an expression.\\*
Example: \code{consult (bar \$x b c)}\\*
\code{consult (\& (foo 4 "String") (bar \$x b c))}\\*
\code{consult (|| (foo \$x "String") (bar \$x b c))}

\pgindex{conclude (oprs)}
\item \code{conclude \var{expression}}. Conclude the \var{expression}
(\pxref{General Expressions}) in the database. You cannot conclude an
expression with unbound variables, and you can only conclude expressions, not
gexpressions.\\*
Example: \code{conclude (bar a b c)}, and\\*
\code{conclude (\~{} (foo 2 3 (+ 2 3)))}, are accepted, however\\*
\code{conclude (bar \$x b c)} is not allowed because of the variable, nor is\\*
\code{conclude (\& ( bar boo) (boo bar))} because of the conjunction.


\pgindex{show db (oprs)}
\item \code{show db}. This command displays all the expressions which
are currently contained in the database. They are not displayed in any
particular order, so it can be rather tedious to look for a particular fact.

\pgindex{save db (oprs)}
\item \code{save db \file{file\_name}}. This command saves the contents of the
database in a the file \file{file\_name}. It is saved in a format suitable to be
read by the kernel. \\*
Example: \code{save db "my-database.db"}\\*
\code{save db "/usr/name/oprs/application.db"}

\pgindex{empty fact db (oprs)}
\item \code{empty fact db}. Empty the database. It clears and frees all the contents
of the database. Functional facts, closed world predicates and basic events
\emph{declarations} are preserved.

\pgindex{load db (oprs)}
\item \code{load db \file{file\_name}}. Load the content of \file{file\_name}
in the database. \xref{OPRS Kernel Loading Commands} for more information on
this command.

\end{itemize}

\section{\CPK{} OP Library Commands}
\node{OPRS Kernel OP Library Commands}
\cpindex{OPRS Kernel OP Library Commands}

The OP library contains all the OP/procedures which have been loaded in the
\CPK{}. There are a number of commands to load/unload OP files in the OP
library of \aCPK{}, as well as to clear/consult the OP library, and to
set/unset trace on specific OP or OP files (i.e.\ set of OPs loaded from the
concerned file).

\begin{itemize}

\pgindex{delete op (oprs)}
\item \code{delete op \var{op\_name}}. Delete the specified OP from the OP
library. 

\pgindex{delete opf (oprs)}
\item \code{delete opf \var{file\_name}}. Delete all the OP which
were contained in the OP File specified as argument.

\pgindex{show op (oprs)}
\item \code{show op \var{op\_name}}. Print the specified OP from the OP
library.

\pgindex{list op (oprs)}
\item \code{list op}. List all the OPs loaded in the kernel.

\pgindex{list opf (oprs)}
\item \code{list opfs}. List all the OP Files loaded in the kernel.

\pgindex{trace graphic op (oprs)}
\item \code{trace graphic op \var{op\_name} \var{on|off}}. Set the graphic
trace on or off for the specified OP.

\pgindex{trace step op (oprs)}
\item \code{trace step op \var{op\_name} \var{on|off}}. Set the step
status on or off for the specified OP.

\pgindex{trace text op (oprs)}
\item \code{trace text op \var{op\_name} \var{on|off}}. Set the text trace
on or off for the specified OP.

\pgindex{trace graphic opf (oprs)}
\item \code{trace graphic opf \var{file\_name} \var{on|off}}. Set the
graphic trace on or off for all the OPs in the specified loaded OP file.

\pgindex{trace step opf (oprs)}
\item \code{trace step opf \var{file\_name} \var{on|off}}. Set the
step status on or off for all the OPs in the specified loaded OP file.

\pgindex{trace text opf (oprs)}
\item \code{trace text opf \var{file\_name} \var{on|off}}. Set the text
trace on or off for all the OPs in the specified loaded OP file.

\item \code{load opf \file{file\_name}}.  Load all the OPs contained in the
OP File specified as argument. \xref{OPRS Kernel Loading Commands} for more
information on this command.

\item \code{reload opf \file{file\_name}}.  Unload and then load all the OPs
contained in the OP File specified as argument. \xref{OPRS Kernel Loading Commands} for more information on this command.

\pgindex{consult relevant op (oprs)}
\item \code{consult relevant op goal|fact}. Return the OPs which are relevant for
the goal or the fact given as an argument. Relevant OPs are not applicable.
These are just the OPs which may be considered for applicability.

\pgindex{consult applicable op (oprs)}
\item \code{consult applicable op goal|fact}. Return the OPs which are applicable, with
their binding environment (\pxref{Frames and Binding Environments}) for a
particular goal or fact. Note that this applicable OPs will not be
executed\dots{} Therefore this command is not equivalent to the \code{add}
command (see below). However, the fact (if a fact is used for this
consultation) is concluded in the database and then retracted from the
database, as if it was a basic event fact (\pxref{Basic Events}).

\end{itemize}

\section{\CPK{} Loading Commands}
\node{OPRS Kernel Loading Commands}
\cpindex{OPRS Kernel Loading Commands}

\textit{FIXME: The following seems inconsistent:  first we say that files can be
  relative to the current directory, or absolute, and then we say that they
  files are searched for using the data path.  That suggests to me that, in
  fact, the files can be named \emph{relative to the data path} (and \emph{not}
  the current directory), or they can be given as absolute names (in which case
  the data path will not be searched).  I believe that unless the current
  directory (as `.') is in the data path, it will not be treated specially.  Is
  that right?}

File names can be given relative to the current directory or absolute
(starting with a \samp{/}). This rule also applies to files loaded by
means of commands in include files. Remember that files are searched in the
\code{OPRS\_DATA\_PATH} path (\pxref{OPRS Kernel Environment Variables}).

\begin{itemize}

\pgindex{set oprs\_data\_path (oprs)}
\item \code{set oprs\_data\_path \var{string}}. Override the OPRS\_DATA\_PATH to the given
value. This command has priority over the OPRS\_DATA\_PATH given as environment
variable or as argument to the \code{oprs} command. Note that you can use environment variable (e.g.\ \$\{HOME\}, etc.),  in the string.\\*
Example: \code{set oprs\_data\_path "data:\$\{HOME\}/openprs/data:."}\\*
\code{set oprs\_data\_path "\$\{OPRS\_DATA\_PATH\}:\$\{ROBOTPKG\_BASE\}/share/openprs/data:."}


\pgindex{show oprs\_data\_path (oprs)}
\item \code{show oprs\_data\_path}. Print the current OPRS\_DATA\_PATH value.

\pgindex{include (oprs)}
\item \code{include \var{file\_name}}. Execute all the commands in
\var{file\_name}. The recommended extension for these files is \file{.inc}.
Include file can contain other include directives. Only two commands are
forbidden in include files: \code{connect} and \code{disconnect}
(\pxref{Include File Format}). Include files can be loaded at start-up time with the \code{-x} option
(\pxref{Arguments to the oprs Command}).

\pgindex{require (oprs)}
\item \code{require \var{file\_name}}. Execute all the commands in \var{file\_name}.
This command is used to load an include file. It is exactly like the
\code{include} command (see above), except that it will check that
the file has not already been loaded with another require call.

\pgindex{load db (oprs)}
\item \code{load db \var{file\_name}}. Load all the facts contained in
\var{file\_name}. Note that the format used in \COPRSDE{} is slightly different
from the one used in the SRI version of \OPRS{}. The database file contains a list of facts,
not just the facts in a file (\pxref{Database File Format}). If you have used
the Lisp version of OPRS, you can convert your already existing database file by
just adding an open parenthesis '(' at the beginning, and a closing parenthesis
')' at the end. Functional facts and closed world predicate declarations are no
longer in the database file, but are issued as commands (\pxref{OPRS Kernel Database Commands}).

\pgindex{load opf (oprs)}
\item \code{load opf \var{file\_name}}. Load all the OPs contained in the
  file \var{file\_name}. \var{file\_name} can be \file{.opf} OP file or a
  \file{.dopf} file. In fact, if a newer \file{.dopf} file exist, \CPK{}
  will load it instead of the \file{.opf}. The \OPEditor{} accepts different
  OP File formats (\pxref{OP File Format}). However, the \CPK{} (to keep it
  as small and as efficient as possible) only accepts OPF File format
  (\file{.opf} or \file{.dopf} suffix). If you wish to load another format,
  it is necessary to load it under the \OPEditor{} and save it under OPF
  File format. For more information on the compilation process
  (\pxref{Procedure and Expression Compilation and Parsing}).

\pgindex{delete opf (oprs)}
\item \code{delete opf  \var{file\_name}}. Delete all the OPs which
were contained in the OP File specified as argument.

\pgindex{reload opf (oprs)}
\item \code{reload opf  \file{file\_name}}.  Delete and then load all the OPs
contained in the OP File specified as argument. This command keeps track of the
OP which were graphic/text traced. If the specified OP file was not loaded,
then it is equivalent to a load.

\pgindex{empty op db (oprs)}
\item \code{empty op db}. Empty the OP Library. It clears and frees all the
OPs loaded in the kernel. Memory is reclaimed and will be used by the
system. This command can be used while OP are being executed.

\end{itemize}

\section{\CPK{} Trace Commands}
\node{OPRS Kernel Trace Commands}
\cpindex{OPRS Kernel Trace Commands}
\pgindex{trace (oprs)}

There are many ways to trace various parts of the \CPK{} execution.
Most of these traces can be set/unset in the \XPK{} using the trace
menu (\pxref{OPRS Trace}). 

The general syntax is:

\code{trace feature on|off}

\begin{itemize}

\pgindex{trace relevant op (oprs)}
\item \code{trace relevant op on|off} Turn on or off information on relevant
OPs (quite verbose).

\pgindex{trace load op (oprs)}
\item \code{trace load op on|off} Turn on or off information on the
compilation of OPs. (very verbose)

\pgindex{trace applicable op (oprs)}
\item \code{trace applicable op on|off} Turn on or off information on the set of
applicable OPs.

\pgindex{trace conclude (oprs)}
\item \code{trace conclude on|off} Turn on or off information on fact concluded
in the database from the parser. This can be useful if you conclude fact from
the parser using internal functions such as \code{send\_command\_to\_parser}.

\pgindex{trace fact (oprs)}
\item \code{trace fact on|off} Turn on or off information on facts
posted in the kernel.

\pgindex{trace goal (oprs)}
\item \code{trace goal on|off} Turn on or off information on the goal
posted in the kernel.

\pgindex{trace suc\_fail (oprs)}
\item \code{trace suc\_fail on|off} Turn on or off information on the
success or failure of OPs.

\pgindex{trace intend (oprs)}
\item \code{trace intend on|off} Turn on or off information in the
intention operation in the kernel.

\pgindex{trace intention failure (oprs)}
\item \code{trace intention failure on|off} Turn on or off information on
intention failure. When an intention fails, the kernel will print the chain of
goals which failed and lead to the intention failure. 

\pgindex{trace send (oprs)}
\item \code{trace send on|off} Turn on or off information on messages sent
by the kernel.

\pgindex{trace receive (oprs)}
\item \code{trace receive on|off} Turn on or off information on messages
received by the kernel.

\pgindex{trace graphic (oprs)}
\item \code{trace graphic \var{on|off}}. Will set the graphic
trace on or off (general flag).

\pgindex{trace text (oprs)}
\item \code{trace text \var{on|off}}.  Will set the text trace
on or off for (general flag).

\pgindex{trace db (oprs)}
\item \code{trace db on|off} Turn on or off traces on the database
operations.

\pgindex{trace db frame (oprs)}
\item \code{trace db frame on|off} Turn on or off the printing of the frames
while consulting the database.

\pgindex{trace thread (oprs)}
\item \code{trace thread on|off} Turn on or off traces on thread creation and
merging.

\pgindex{trace all (oprs)}
\item \code{trace all on|off} Equivalent to turn on or off: \code{db},
\code{receive}, \code{send}, \code{intend}, \code{suc\_fail}, \code{goal},
\code{relevant op}, \code{load op}, \code{applicable op} and \code{fact}.

\end{itemize}

All these trace options can be set or unset by the appropriate command in
an include file.

\section{\CPK{} Run Option Commands}
\node{OPRS Kernel Run Option Commands}
\cpindex{OPRS Kernel Run Option Commands}

The option commands allow the user to set or unset some options of the OPRS
Kernel. Most of these options can be set/unset in the \XPK{} using the options
menu (\pxref{OPRS Run Option}).

The general syntax is:

\code{set option on|off}

\begin{itemize}

\pgindex{set eval post (oprs)}
\item \code{set eval post on|off}. Turn on or off the current-quote
mechanism, (\pxref{Current and Quote}). Default value: \code{on}.

\pgindex{set parallel post (oprs)}
\item \code{set parallel post on|off} Turn on or off the parallel posting of
goals. When this option is on, one goal for each thread active in the
current intention will be posted. Default value: \code{on}.

\pgindex{set parallel intend (oprs)}
\item \code{set parallel intend on|off} Turn on or off the parallel intending
of op-instance. Default value: \code{on}.

\pgindex{set parallel intention (oprs)}
\item \code{set parallel intention on|off} Turn on or off the parallel
intention execution. When it is \code{on}, all the intention at the root of the
graph are executed. For this option to be really useful, the  \code{parallel
intend} option should be \code{on}. Default value: \code{on}.
\strong{This option has some very important consequences on the standard
behavior of the kernel}. In any case the kernel always checks that a particular
OP Instance has not been already intended before intending it. This is to make
sure, for example, that you do not intend again from a meta level OP, a OP
instance already intended by the main loop or another meta level OP. Moreover,
the kernel always check that a OP Instance intended for a particular goal is
intended in the proper place, i.e.\ it is not intended if there is already
another OP instance which has been intended for the same goal. Note however,
that it may be intended later if it is still applicable and if the other one
has failed.

\pgindex{set time\_stamping (oprs)}
\item \code{set time\_stamping on|off} Turn on or off the time stamping of
various date (for facts, goals, creation date, soak date, etc.). Time stamping
is quite expensive, which is the reason why this option exists.  Default value:
\code{off}.

\end{itemize}

All these trace options can be set or unset by the appropriate command in
an include file.

\section{\CPK{} Meta Level Option Commands}
\node{OPRS Kernel Meta Level Option Commands}
\cpindex{OPRS Kernel Meta Level Option Commands}

The option commands allow the user to set or unset some options of the OPRS
Kernel. Most of these options can be set/unset in the \XPK{} using the options
menu (\pxref{OPRS Meta Level Option}).

The general syntax is:

\code{set option on|off}

\begin{itemize}

\pgindex{set meta (oprs)}
\item \code{set meta on|off}. Turn on or off the meta-level mechanism,
(\pxref{Meta Level Reasoning}).  Turning it \code{off} greatly increases the
performance of the system. This flag is a general flag. When it is \code{on},
then you need to select which specific meta fact you want the kernel to
conclude or not.

\pgindex{set soak (oprs)}
\item \code{set soak on|off}. Turn on or off the posting of the meta fact
\code{(SOAK)}, (\pxref{SOAK and other Meta Facts}). Default value:
\code{on}.

\pgindex{set meta fact (oprs)}
\item \code{set meta fact on|off}. Turn on or off the posting of the meta
fact \code{(FACT-INVOKED-OPS)}, (\pxref{SOAK and other Meta Facts}). Default
value: \code{on}.

\pgindex{set meta goal (oprs)}
\item \code{set meta goal on|off}. Turn on or off the posting of the meta
fact \code{(GOAL-INVOKED-OPS)}, (\pxref{SOAK and other Meta Facts}).  Default
value: \code{on}.

\pgindex{set meta fact op (oprs)}
\item \code{set meta fact op on|off}. Turn on or off the posting of the
meta fact \code{(APPLICABLE-OPS-FACT)}, (\pxref{SOAK and other Meta Facts}).
Default value: \code{off}.

\pgindex{set meta goal op (oprs)}
\item \code{set meta goal op on|off}. Turn on or off the posting of the
meta fact \code{(APPLICABLE-OPS-GOAL)}, (\pxref{SOAK and other Meta Facts}).
Default value: \code{off}.

\end{itemize}

All these trace options can be set or unset by the appropriate command in
an include file. For efficiency reasons, it is strongly recommended to only use the
meta-level options required by the application.

\section{\CPK{} Compiler/Parser Option Commands}
\node{OPRS Kernel Compiler/Parser Option Commands}
\cpindex{OPRS Kernel Compiler/Parser Option Commands}

The checking commands allow the user to set or unset some compiler/Parser
checking of the OPRS Kernel. Most of these checkings can be set/unset in the
\XPK{} using the options menu (\pxref{OPRS Compiler/Parser Option}).

The general syntax is:

\code{set checking on|off}

\begin{itemize}

\pgindex{set action (oprs)}
\item \code{set action on|off} Turn on or off some checking on the action
compilation/parsing. In particular, it will check if an action calls a function
declared as an evaluable function. \xref{Action Checking}. Default value:
\code{on}.

\pgindex{set function (oprs)}
\item \code{set function on|off} Turn on or off some checking on the function
compilation/parsing. Note that it will require all symbols used in place of a
function to be declared as a function. Symbols declared as evaluable functions
in the kernel are declared as function de facto. \xref{Function Checking}. Default value: \code{on}.

\pgindex{set predicate (oprs)}
\item \code{set predicate on|off} Turn on or off some checking on the predicate
compilation/parsing. Note that it will require all symbols in place of a
predicate to be declared. Symbols declared as functional fact or basic events or
closed world predicates are declared as predicate de facto. \xref{Predicate
Checking}. Default value: \code{on}.

\pgindex{set symbol (oprs)}
\item \code{set symbol on|off} Turn on or off some checking on the symbol
compilation/parsing. All symbols declared by other means (evaluable functions,
predicates, actions, cwp, basic events, etc.) are declared as symbol de
facto. \xref{Symbol Checking}. Default value: \code{on}.

\end{itemize}

All these checking can be set or unset by the appropriate command in an include
file. In development phase, it is stronly recommended to keep all these checkings
on.

\section{\CPK{} Declaration Commands}
\node{OPRS Kernel Declaration Commands}
\cpindex{OPRS Kernel Declaration Commands}

\begin{itemize}

\pgindex{declare be (oprs)}
\item \code{declare be \var{predicate}}. Declare the \var{predicate} as a basic
event predicate (\pxref{Basic Events}). This declaration is local to the
\CPK{} the user is connected to.\\*
Example: \code{declare be foo}

\pgindex{declare cwp (oprs)}
\item \code{declare cwp \var{predicate}}. Declare the \var{predicate} as a closed
world predicate (\pxref{Closed World Predicates}). This declaration is local to
the \CPK{} the user is connected to. \\*
Example: \code{declare cwp foo}

\pgindex{declare ff (oprs)}
\item \code{declare ff \var{predicate} \var{integer}}. Declare the
\var{predicate} as functional fact for the argument integer (\pxref{Functional Facts}). This declaration is local to the \CPK{} the user is connected
to. Keep in mind that all functional fact predicate are also considered as
closed world predicate.\\*
Example: \code{declare ff position 1}\\*
\code{declare ff connection\_status 2}

\pgindex{declare function (oprs)}
\item \code{declare function \var{function}}. Declare \var{function} as a
function (\pxref{Function Checking}).\\*
Example: \code{declare function pressure-of}\\*
\code{declare function status}

\pgindex{declare id (oprs)}
\item \code{declare id symbol}. Declare the symbol as an id, therefore, the OP
compiler does not complain if it encounters this symbol. This command is
useful if and only if you perform it before the first occurrence of the
symbol in the OPs or in the database. As a consequence, most likely it
will appears at the beginning of the include file. \xref{Symbol Checking}.

\pgindex{declare op\_predicate (oprs)}
\item \code{declare op\_predicate \var{predicate}}. Declare the
\var{predicate} as OP predicate (\pxref{OP Predicates}). This declaration is not
mandatory at all, but considerably improve the speed of the kernel.\\*
Example: \code{declare op\_predicate foo}\\*
\code{declare op\_predicate print}

\pgindex{declare predicate (oprs)}
\item \code{declare predicate \var{predicate}}. Declare \var{predicate} as
a predicate (\pxref{Predicate Checking}).\\*
Example: \code{declare predicate foobar}\\*
\code{declare predicate connection}

\pgindex{undeclare be (oprs)}
\item \code{undeclare be \var{predicate}}. Undeclare the \var{predicate} as a
basic event predicate (\pxref{Basic Events}). \\*
Example: \code{undeclare be foo}

\end{itemize}

\section{\CPK{} Listing Commands}
\node{OPRS Kernel Listing Commands}
\cpindex{OPRS Kernel Listing Commands}

\begin{itemize}

\pgindex{list action (oprs)}
\item \code{list action}. List all the functions which have been declared as
action (\pxref{Using Action OPs}).\\* 
Example: \code{list action}

\pgindex{list all (oprs)}
\item \code{list all}. Equivalent to a \code{list be}, \code{list cwp},
\code{list ff}, \code{list predicate}, \code{list evaluable predicate},
\code{list op\_predicate}, \code{list function}, \code{list evaluable function}, \code{list action}.\\*  
Example: \code{list all}

\pgindex{list be (oprs)}
\item \code{list be}. List all the predicates which have been declared as basic
event predicate (\pxref{Basic Events}).\\*
Example: \code{list be}

\pgindex{list cwp (oprs)}
\item \code{list cwp}. List all the predicates which have been declared as
closed world predicate (\pxref{Closed World Predicates}).\\* 
Example: \code{list cwp}

\pgindex{list evaluable function (oprs)}
\item \code{list evaluable function}. List all the functions which have been declared as
evaluable function (\pxref{Evaluable Functions}).\\* 
Example: \code{list evaluable function}

\pgindex{list evaluable predicate (oprs)}
\item \code{list evaluable predicate}. List all the predicates which have been declared as
evaluable predicate (\pxref{Evaluable Predicates}).\\* 
Example: \code{list evaluable predicate}

\pgindex{list ff (oprs)}
\item \code{list ff}. List all the predicates which have been declared as
functional fact predicate (\pxref{Functional Facts}).\\* 
Example: \code{list ff}

\pgindex{list function (oprs)}
\item \code{list function}. List all the functions which have been declared.\\* 
Example: \code{list function}

\pgindex{list op\_predicate (oprs)}
\item \code{list op\_predicate}. List all the predicates which have been declared as
op predicate (\pxref{OP Predicates}).\\* 
Example: \code{list op\_predicate}

\pgindex{list predicate (oprs)}
\item \code{list predicate}. List all the predicates which have been declared.\\* 
Example: \code{list predicate}

\end{itemize}

\section{\CPK{} Dumping/Loading Commands}
\node{OPRS Kernel Dumping/Loading Commands}
\cpindex{OPRS Kernel Dumping/Loading Commands}

Since version 1.4, \COPRS{} provides a mechanism to save OP and fact database in
a binary compiled dump format. This binary dump format present a number of
advantages.

\begin{description}

\item[Faster reload] The main advantage of using OP and database dump/load is
the load speed compare to loading OP or database files. For large applications,
with hundreds of OP, the startup time can be critical, and it is always much
faster (5 or more times faster) to load a dump file than the equivalent OP
or database files. In fact, when one load a OP file, the kernel recompiles the
OP in some internal structure, while if you load a dump OP file, the structures
are just loaded in memory, avoiding a costly parsing and compilation.

\item[More than just OP files] The OP dump files contains in fact more than
just the OP description, they also contain all the declarations of predicates,
functions, and symbols mentioned in the OPs.

\item[Architecture and endian independant] The dump format is intentionaly
architecture and endian independant. One can create a dump file under a Pentium
running Windows NT and reload it under a Sparc running Solaris or a 680x0 board
under VxWorks.

\item[Graphic and non graphic version of OP] Graphic information is dumped
according to the kernel from which you dump the OPs.  That is graphical
information will be dumped, if the OP is dumped from 
an \XPK{}; no graphical information will be dumped if dumping from \aCPK{}). 
Similarly, when loading an OP dump, the
graphic information is loaded if and only if it is both present in the dump and if
the loading kernel may use it (i.e.\ an \XPK{}).

\end{description}

There are some drawbacks to the use of the dump/load facilities, and also some
misunderstandings:

\begin{description}

\item[Unreadable format] The dump format is almost unreadable to the
common user (and even programmer)... Therefore, all OP files should also be
kept in source format (\file{.opf}).

\item[Memory consumption] The dump and reload of OP and database dump files
requires some memory allocation.  Caution will be required when memory is sparse (under
VxWorks, for example). Some tables are required to perform the dump and the
load. These tables are temporarily allocated and are freed afterward. 

\item[No C compiled code included] C Compiled code, i.e.\ code linked by the
user in the \PK{} is not dumped in the \OPRS{} dump files. The main reason is
that unlike the \OPRS{} compiled code, C compiled code is not architecture
independant. Therefore, when you load a \OPRS{} dump file, the kernel will
complain if it cannot find evaluable function, predicate, or action code it
needs.

\end{description}

The currently supported commands are:

\begin{itemize}

\pgindex{dump op (oprs)}
\item \code{dump op \file{file\_name}}.  Dump in binary format all the OP
currently loaded in the kernel. The suggested suffix for the dump OP file is
\file{.dopf}. If this command isexecuted from the \XPK{}, graphical information
is saved in the file.\\* 
Example: \code{dump op "op-ex.dopf"}

\pgindex{dump all opf (oprs)}
\item \code{dump all opf}.  Dump in binary format all the OP files
currently loaded in the kernel. Each file in its own \file{.dopf} file. This 
command is very useful when an application is ready and one want to compile
all the OPs at once.\\* 
Example: \code{dump op "op-ex.dopf"}

\pgindex{dump db (oprs)}
\item \code{dump db \file{file\_name}}.  Dump in binary format all the facts
currently in the database. The suggested suffix for the dump db file is
\file{.ddb}.\\* 
Example: \code{dump db "op-ex.ddb"}

\pgindex{load dump op (oprs)}
\item \code{load dump op \file{file\_name}}.  Load all the OP in the dump OP
file which must be in binary format, and add them in the kernel (except for the
OP already loaded). The suggested suffix for the dump OP file is \file{.dopf}.
If this command is executed from the \XPK{}, and the dump OP file was produced
from an \XPK{}, the graphical information is restored, otherwise, it will be
unavailable (but the OP will still remain executable).  However, if it is
executed from \aCPK{}, graphical information if present is discarded. \\*
Example: \code{load dump op "op-ex.dopf"}

\pgindex{load dump db (oprs)}
\item \code{load dump db \file{file\_name}}.  Load and add in the database all
the fact in the dump fact binary format file. The suggested suffix for the dump
db file is \file{.ddb}.\\* 
Example: \code{load dump db "db-ex.ddb"}

\end{itemize}

The dump/load mechanism is the first step of a broader mechanism which will, in
future releases, provide other facilities. For example, a future version of
\COPRS{} will provide warm boot capabilities (i.e.\ one will be able to dump a
kernel state and later reload it and continue from the point where it was
dumped). In fact, the warm boot feature is more or less already present in the
current version but is not currently supported (i.e.\ use it at your own risk).

\begin{itemize}

\pgindex{dump kernel (oprs)}
\item \code{dump kernel \file{file\_name}}.  Dump in binary format the complete
kernel (i.e.\ the database, the OPs, and all the intentions). The suggested
suffix for the dump kernel file is \file{.dkrn}. If this command is executed 
from the \XPK{}, graphical information is saved in the file.\\*
Example: \code{dump kernel "krn-ex.dkrn"}

\pgindex{load kernel (oprs)}
\item \code{load dump kernel \file{file\_name}}.  Load the kernel contained
in the dump kernel file which must be in binary dump kernel format, i.e.\ add
the loaded fact in the database, add the loaded OP in the OP library (except
for the OP already loaded), and replace the intention graph with the one loaded
from the file. The suggested suffix for the dump OP file is \file{.dkrn}.  If
this command is executed from the \XPK{}, and the dump kernel file was produced
from an \XPK{}, the graphical information is restored, otherwise, it will be
unavailable (but the OP will still remain executable).  However, if it is
executed from \aCPK{}, graphical information, if present, is discarded. \\*
Example: \code{load dump kernel "krn-ex.dkrn"}

\end{itemize}

\section{\CPK{} Status and Control Commands}
\node{OPRS Kernel Status and Control Commands}
\cpindex{OPRS Kernel Status and Control Commands}

A number of commands exist to display the status of \CPK{} and to control
its execution.

\begin{itemize}

\pgindex{show run status (oprs)}
\item \code{show run status}. Display all the current status of the
kernel. This command is usually sent by the \OPRSS{}, with a \code{transmit}
command. 

\pgindex{step (oprs)}
\item \code{step}. This command will step the execution of the \CPK{}. This
command is usually sent by the \OPRSS{}, with a \code{transmit} command.  This
will lead to step through one loop of the \CPK{}. Note that one loop
execution does not always produce any noticeable or visible effect\dots{}.

\pgindex{next (oprs)}
\item \code{next}. This command will next the execution of the \CPK{}. This
command is usually sent by the \OPRSS{}, with a \code{transmit} command.
Executing this command will lead the kernel to run until the control hits an
edge of step traced OP. This is very useful when you graphic trace OPs.  At
each click, the execution goes from one traced edge to the next traced edge
(whatever execution happens in between).


\pgindex{halt (oprs)}
\item \code{halt}. This command will halt the execution of the \CPK{}. This
command is usually sent by the \OPRSS{}, with a \code{transmit} command. While
the kernel is halted, you can perform most command, such as consulting the fact
or OP Library, adding new fact or new goal (in which case they will be taken
into account whenever the kernel is restarted), displaying a particular OP,
load new OPs, etc.

\pgindex{run (oprs)}
\item \code{run}. This command will run the execution of the \CPK{}. This
command is usually sent by the \OPRSS{}, with a \code{transmit} command.
It will restart a stopped \CPK{}.

\pgindex{reset kernel (oprs)}
\item \code{reset kernel}. Reset the kernel by flushing all the
intentions in the intention graph as well as flushing all the goals and facts
in the input buffers of the kernel. This does not stop the kernel and this does
not flush the fact database and the OP Library.

\end{itemize}

\section{\CPK{} Miscellaneous Commands}
\node{OPRS Kernel Miscellaneous Commands}
\cpindex{OPRS Kernel Miscellaneous Commands}

\begin{itemize}

\pgindex{show intention (oprs)}
\item \code{show intention}. Display all the intentions in the intention graph.
It gives an extensive status of the intentions and their component (thread,
status, waiting condition, joining, etc.).

\pgindex{show condition (oprs)}
\item \code{show condition}. Display all the conditions currently active in th
\CPK{}. It gives an extensive status of the conditions (waiting or preserve
condition, as well as their ``evolving'' status).

\pgindex{show memory (oprs)}
\item \code{show memory}. Display some information on the memory usage of the
kernel. 

\pgindex{show variable (oprs)}
\item \code{show variable}. Display all the currently used global variables and
their binding.

\pgindex{disconnect (oprs)}
\item \code{disconnect}. Instruct the connected \COPRS{} to leave the
\code{stdin} and give it back to the \OPRSS{}. The \COPRS{} client returns
in run mode, and execute its main loop again.

\pgindex{unify (oprs)}
\item \code{unify expression expression}. Unify two expressions
(\pxref{General Expressions}). This can be used to check the result of the
unification mechanism.

\pgindex{echo (oprs)}
\item \code{echo gexpression|gtexpression|gmexpression}. Echo the general
expression, general temporal expression or general meta expression to the
screen. This is used to check that an expression is properly parsed.

\pgindex{send (oprs)}
\item \code{send name message}. Send the message (an Expression) to the
\COPRS{} named \var{name}.

\pgindex{add (oprs)}
\item \code{add goal|fact}. Add a goal (a Temporal Expression) or a fact
(an Expression) in the current \CPK{}. Most of the time, the user
would prefer to use the similar command from the \OPRSS{} (which is the
same except it take the name of the kernel as first argument). Note that
the kernel will not execute any applicable OP because of this fact or
goal before it is returned to run mode with the \code{disconnect} command.

\pgindex{stat db (oprs)}
\item \code{stat db}. Print a report on the use of the
various hashtables in the database (occupation, collision, etc.). It can be
used to tune your application by using the appropriate arguments to the
\code{oprs} or \code{xoprs} command (\pxref{Arguments to the oprs Command}).

\pgindex{stat id (oprs)}
\item \code{stat id}. Print a report on the use of the
symbol hashtables in the kernel (occupation, collision, etc.). It can be used
to tune your application by using the appropriate arguments to the \code{oprs}
or \code{xoprs} command (\pxref{Arguments to the oprs Command}).

\pgindex{stat all (oprs)}
\item \code{stat all}. Print a report on the use of all
the various hashtables in the kernel (occupation, collision, etc.). It can be
used to tune your application by using the adequate arguments to the \code{oprs}
or \code{xoprs} command (\pxref{Arguments to the oprs Command}).

\pgindex{load external (oprs)}
\item \code{load external \file{file\_name} \var{entry\_point}}. This is a new
  feature since OpenPRS 1.1. It allows the user to load external binary code in
  the kernel. It loads (with \code{lt\_dlopen}) the library/module (.so)
  \file{file\_name} (produced with libltdl) and try to call the string
  \var{entry\_point} after looking for it with \code{dl\_sym}. This is now the
  preferred way to extend an OpenPRS kernel with new actions, evaluable
  functions and predicates. The standard rules to search the path are used to
  localized the \file{file\_name} library/module. Check the libltdl
  documentation for further information on how to produce and install the
  library/module. There are examples of actions, evaluable functions and
  predicates in the following files: \file{user-action.c}
  \file{user-ev-function.c} \file{user-ev-predicate.c}. Check also the
  \file{Makefile.am} file in the \file{src} sub directory to find how the .la
  are produced.\\*
Example: \code{load external "user-action" "declare\_user\_action''}


\pgindex{q (oprs)}
\pgindex{quit (oprs)}
\pgindex{exit (oprs)}
\item \code{q|quit|exit|EOF}. Quit the kernel. This command also disconnects
you. It will execute the:\\*
\code{end\_kernel\_user\_hook}\\*
function which can be used to do some cleanup (\pxref{User Hooks}).

\pgindex{show version (oprs)}
\item \code{show version}. Print the version of the \CPK{}.

\pgindex{show copyright (oprs)}
\item \code{show copyright}. Print the copyright notice.

\pgindex{help (oprs)}
\item \code{help|h|?}. Print an on-line help.

\end{itemize}

\section{Include File Format}
\node{Include File Format}
\cpindex{Include File Format}

\dfn{Include files} are files containing commands to be executed by \aCPK{}. The
recommended, but not enforced, extension for these files is \file{.inc}.
Include file can contain other include directives. Only two commands are
forbidden in include file: \code{connect} and \code{disconnect}. Include files
can be loaded at start-up time with the \code{-x} option (\pxref{Arguments to the oprs Command}). Lines beginning with the \samp{;} character are ignored and
considered as comments. A number of include files are provided with the
\COPRSDE{} distribution. 

Here is an example of an include file:

\begin{verbatim}
;;; This is a comment
declare cwp property-p
trace load op off
include "/usr/local/oprs/data/new-default.sym"
load opf "/usr/local/oprs/data/new-default.opf"
declare id factorial
declare id recursive
declare id prefer-iterative
declare id prefer-recursive
declare id print-factorial
declare id sssoak
declare id tas-fact
declare id foo
declare id test_par
declare id TT
declare cwp prefer-recursive
declare cwp prefer-iterative
load opf "/usr/local/oprs/data/fact-meta.opf"
trace graphic opf "/usr/local/oprs/data/fact-meta.opf" on
trace text opf "/usr/local/oprs/data/fact-meta.opf" on
trace graphic op |Print Factorial| off
\end{verbatim}

\chapter[Syntax and Semantics\ldots]{Syntax and Semantics Used in the \COPRSDE{}}
\node{Syntax and Semantics Used in the OPRS Development Environment}
\cpindex{Syntax and Semantics Used in the \COPRSDE{}}
\cpindex{Syntax Used in the \COPRSDE{}}
\cpindex{Semantics Used in the  \COPRSDE{}}
\cpindex{Grammar Used in the \COPRSDE{}}

The syntax and the associated semantics is the same in the
\CPK{}, \XPK{}, \OPE{} and \OPRSS{} modules. The same grammar is used and syntax
checking is done and enforced whenever possible. In other words, unless you hand-edit
the OP files themselves, it is very unlikely that an OP produced by the
\OPE{} will be rejected by the \CPK{}.

A Lex/Yacc like format grammar can be found in \nxref{Grammar Used in the OPRS Development Environment}. The grammar is recursive, therefore, it cannot be
easily presented with a bottom up approach without making the assumption that
some elements are known.
% FIXME: what does this sentence mean?  What is meant by a bottom-up approach?

Note that although the syntax is very much like Lisp, there is no Lisp
interpreter behind the reader (\pxref{LISPLIST}).


\section{Variables}
\node{Variables}
\cpindex{Variables}

A \dfn{variable} is a symbol which can  or cannot be bound to different
values depending on the context (\pxref{Frames and Binding Environments}). Variables
allow the user to write partially specified expressions. Depending on
the context, a variable can be existentially or universally
quantified. These quantifications are usually implicit but obvious. Most often
variables are existentially quantified, i.e.\ the expression containing
the variable is interpreted with one possible value of all the possible values
this variable can take. We will point out situations where variables are
to be interpreted in a universally quantified way. Finally, there are operators
and functions to force universal quantification (\pxref{Universal
Quantification of Variables}).

There are two types of variables in \COPRS. \dfn{Logical variables}
(their name starts with the dollar character, \samp{\$}) and \dfn{program
variables} (their name starts with the at sign character, \samp{@}).



\subsection{Logical Variables}
\node{Logical Variables}
\cpindex{Logical Variables}

Logical variables start with the dollar character \samp{\$}.\\*
Example: \code{\$x}, \code{\$y} and \code{\$FOO}.

The behavior of these variables is quite standard in logic programming (as
in PROLOG \cite{Clocksin-Mellish84}).  They are bound once and remain bound. If the 
execution of the branch on which they were bound is successful,
then they stay bound (this is commonly used to bring values back to a caller) .

% FIXME: I believe that this just means that the variables are lexically scoped,
% and the scope range is the procedure or consultation expression.  The sentence
% about making a copy of the variable confused me a bit.  This is just normal
% lexical scoping, right?
The scope of these variables is the procedure or the consultation expression in
which they appear. Moreover, in recursive procedure calls, a new ``copy'' of the
variables is done.

\subsection{Program Variables}
\node{Program Variables}
\cpindex{Program Variables}

Program variables start with the at sign character \samp{@}.\\*
Example: \code{@x}, \code{@y} and \code{@FOO}.

\figuregif[scale=0.5]{op-ite-fact-if-then-else}{A OP to Compute Factorial with an Inner Loop and Program Variables.}{ite-fact-prog-var-op}

These variables are provided for convenience. They can be bound and rebound
at any time, even if they are already bound to some value. They are not
used in invocation or context parts due to their inability to keep a
value. They are mostly used inside the body of a procedure in constructions
such as loops (See Figure \ref{ite-fact-prog-var-op}).

% FIXME: I believe that this just means that the variables are lexically scoped,
% and the scope range is the procedure or consultation expression.
The scope of these variables is the procedure or the consultation expression in
which they appear. Moreover, in recursive procedure calls, a new ``copy'' of the
variables is done.

\subsection{Global Variables}
\node{Global Variables}
\cpindex{Global Variables}

Global variables start with two at sign characters \samp{@@}.

These variables are provided for convenience. They can be bound and rebound
at any time (like Program Variables \pxref{Program Variables}), even if
they are already bound to some value. Their main characteristic is that
they are visible all over the \CPK{} or \XPK{} in which they are used.
The scope of these variables is the whole kernel.

Note that this mechanism should not be used in place of the database itself, it
should only be used for information widely used, and ever changing, and which
are difficult or expensive to recompute.

\section{Terms}
\node{Terms}
\cpindex{Terms}

Terms are an important component of the \COPRS{} syntax. They  are of various
types and are the building blocks used to build more complex
expressions.  Terms are generic, and can be of the following types. For each of
them, we indicate in parenthesis the C type as defined in
\file{oprs-type-pub.h}.



\subsection{Integer as a Term}
\node{Integer as a Term}
\cpindex{Integer as a Term}

\textit{FIXME: I believe that in the latest OPRS kernel integers are always
  32-bit quantities, and so the user need not consult the machine architecture
  to determine minimum and maximum values, etc.}

A term can be an \dfn{integer}. Its C type in the Term structure is
\code{INTEGER}. In the \CPK{}, integers become C \code{int}. A
direct consequence is that they are not bignums (a la Lisp). Therefore,
there are maximum values for these numbers. Check the C compiler and
your machine architecture for specific maximum and minimum values.

Example of integers: (the parser will accept a useless l) \code{0 1 -3 4732 +34l -0 +0 -023l}. \\*
Example of numbers which are probably not recognized as integers:
\code{123123123123123123 --4}.

\subsection{Long long integer as a Term}
\node{Long long integer as a Term}
\cpindex{Long long integer as a Term}

A term can be a \dfn{long long integer}, i.e.\ a 64 bit integer.  Its C
type in the Term structure is then \code{LONG\_LONG}. In the \CPK{}, long
long integers become C \code{long long int}. You can perform computation
on integer larger than the ``regular'' int. Yet, there is a maximum value
(probably 2**(63) - 1). Check the C compiler and your machine architecture
for specific maximum and minimum values.

Example of integers: \code{0ll 1123ll -345345ll +83453234ll}. \\*
Example of numbers which are probably not recognized as long long integers:
\code{121231231233123123123123123 --4l}.

\subsection{Float as a Term}
\node{Float as a Term}
\cpindex{Float as a Term}

A term can be a \dfn{float}. Its C type in the Term structure is
then \code{TT\_FLOAT}. In the \CPK{} these floats are casted in C
\code{double}. Check your C compiler and your machine architecture for
specific maximum and minimum values.

Example of floats: \code{123.234, -45.0, +34.1, 123E-4, -45.90e+23,  45.90e23} \\* 
Example of numbers which are probably not recognized as floats: \code{+.345
234 e34}.

\subsection{String as a Term}
\node{String as a Term}
\cpindex{String as a Term}

A term can be a \dfn{string}. Its C type in the Term structure is then
\code{STRING}. These strings are standard strings, as commonly encountered in
C. They use the same backslash notation as the one used in C. To insert a
\samp{"} in a string you must backslash it with a \samp{\textbackslash}.

Example of strings: \code{"This is a string \$\#\%\$\^{}\%\$\^{} "}, \\*
\code{"This is another  string with a \textbackslash" embedded and even a \textbackslash{}n\\* which will
become new line."} \\*
Example of non strings: \code{"This is a " not a string because of the
char " in it"}.

\subsection{Symbol as a Term}
\node{Symbol as a Term}
\cpindex{Symbol as a Term}

\textit{FIXME: The rules for how the vertical bars are used are not clear.  In
  the example, it looks like the user of vertical bars permits putting spaces
  into a symbol.  It would probably help to specify what characters are and are
  not legal symbol characters.}

A term can be a \dfn{symbol}. Its C type in the Term structure is
then \code{TT\_ATOM}. The case of Symbols may be changed automatically
according to the option used -- either automatically up-cased or down-cased --
unless they are surrounded by vertical 
bars (\samp{|}). In some situations, (such as printing node names,
or script names, the vertical bars are not printed around the symbol).

Example of symbols: \code{nil, t, |Foo Bar|, :BOO, bar}.\\*
Example of non symbols: \code{123il, |\#:|123|, \$g45, @x, \$32a, .asd}.

\subsection{Variable as a Term}
\node{Variable as a Term}
\cpindex{Variable as a Term}

\textit{FIXME: Are variables case-shifted in the same way as symbols?}

A term can be a \dfn{variable}. Its C type in the Term structure is then
\code{VARIABLE}. Variables can be bound, in this case they are always bound to
a Term (another variable for example). This depends on the binding environment
in which they appear.

\textit{FIXME: I added a global variable to the following example.  Please fix
  if that was wrong of me.}

Example of variables: \code{\$g45, \$x, \$32a, @foo, @BoO, @@Global}.

\subsection{Variable List as a Term}
\node{Variable List as a Term}
\cpindex{Variable List as a Term}

A term can be a \dfn{variable list}. Its C type in the Term structure is then
\code{LENV}. Variable lists are used for different functions
(\pxref{Universal Quantification of Variables}), or in 
multi variable special actions (\pxref{Multi Variable Special Action}).

Example of variable list: \code{(\$g45 \$x \$32a @foo @BoO)}.

\subsection{Gtexpression as a Term}
\node{Gtexpression as a Term}
\cpindex{Gtexpression as a Term}

A term can be a \dfn{gtexpression}. Its C type in the Term
structure is then \code{GTEXPRESSION}. \xref{General Temporal
Expressions}. Gtexpression as terms are used in \code{test-and-set}
or \code{apply-subst-in-gtexpr} functions.

Example of gtexpression: \code{(? (foo a \$x)), (achieve (position \$x closed))}.

\subsection{Gexpression as a Term}
\node{Gexpression as a Term}
\cpindex{Gexpression as a Term}

A term can be a \dfn{gexpression}. Its C type in the Term structure is then \code{GEXPRESSION}.
\xref{General Expressions}. Gexpression as terms are used in \code{all} and
\code{n-all} functions. From the reader, only \code{LEXPRESSION} are allowed,
to be able to distinguish them from \code{TERM\_COMP}.

Example of lexpression: \code{(\& (foo \$x b) (bar \$x b))}.

\subsection{Composed Term as a Term}
\node{Composed Term as a Term}
\cpindex{Composed Term as a Term}

A term can be a \dfn{composed term}. Its C type in the Term structure is then \code{TERM\_COMP}.
Beware, these terms look like Lisp lists, but they are not (see below for a
description of the Lisp list). Composed terms are a list which first element is a
function name and the rest of the element of the list are terms. The function
appearing in this context are not always evaluable. Of course, composed terms
can contain composed terms recursively.

Example of composed terms: \code{(+ 1 2), (foo a b), (l\_list 1 2 3 4),
(cdr (.2 4 7 .))}.

\subsection{Lisp List as a Term}
\node{Lisp List as a Term}
\cpindex{Lisp List as a Term}

A term can be a Lisp list. Its C type in the Term structure is then \code{LISP\_LIST}. Lisp lists are
provided for upward compatibility with the Lisp version of \OPRS{}. However, we
do not encourage the use of Lisp functions and lispisms in \COPRS{}. Therefore,
to distinguish Lisp lists from other lists like structure (such as composed
terms), we use a different parenthesis scheme. The Lisp lists are surrounded
with parenthesis followed or preceded with the dot char \samp{.}.  Moreover,
when read by the parser, we only allow terms in the list (so you can still have
lists of lists, etc\dots{}). However, the kernel uses this data structure to
handle list of OP Instances, Goals, Intentions or other internal data structures
when necessary.  In this case the printed form is the name of the structure
followed by the address of the object in memory.  \xref{LISPLIST}
for more on this subject.

Example of Lisp lists: \code{(. 2 4 7 .), (. 2 (.  2 (. 2 4 7 .) 4 7 .) 4 7.)}.

\subsection{User Pointers as a Term}
\node{User Pointers as a Term}
\cpindex{User Pointers as a Term}

A term can be a user pointer. Its C type in the Term structure is then a \code{U\_POINTER}. A user
defined pointer is a pointer on a user created object which he wants to
manipulate. For example, an evaluable function may return such pointer (like
the pointer to a complex data structure), which can then be used by other user
defined evaluable functions to access specific fields of the data structure, or
by user-defined evaluable predicates or actions. The kernel will only consider
the pointer itself, it will not consider the object pointed by the
\code{U\_POINTER}.  Therefore, it will not free it, nor will it copy it or
compare it with other similar object. Last, the comparison of \code{U\_POINTER}
is a pointer comparison.  \code{U\_POINTER} are written with the hexadecimal
printout format of C. \code{U\_POINTER} can be read by the \CXPK{}. For this,
use the \code{0x} prefix and an hexadecimal number.  This can be useful if you
want to consult the database or post a fact or a goal with an expression
containing a \code{U\_POINTER} for which you know a corresponding object
exist. \xref{User Pointers} for more on this subject.

Example of user pointer: \code{0xff30}, \code{0xA120}.

\subsection{Array of Integers as a Term}
\node{Array of Integers as a Term}
\cpindex{Array of Integers as a Term}

A term can be an array of integers. Its C type in the Term structure is then \code{INT\_ARRAY}. Arrays
of integers are read by the various programs of the \COPRSDE{} using the
\samp{[} and a matching \samp{]} square bracket. In this case, the type of the
first element determine the type of the whole array. If it is an
\code{INTEGER}, then the array is an \code{INT\_ARRAY}, if it is a \code{FLOAT},
then the array is a \code{FLOAT\_ARRAY} (see below).  Any subsequent element is
properly casted if possible, if not it is set to \code{0}. The size of arrays
read is the number of element read. Arrays can be created/accessed/set with the
appropriate evaluable functions (\pxref{Array Manipulation Evaluable Functions}) and actions (\pxref{Array Manipulation Actions}). Arrays can also
be created/consulted using the appropriate functions (\pxref{Array Manipulation Functions}).

Example of array of integers: \code{[ 1 2 4 5 0 3 4]}, \code{[1 3 4.5 5 7]}
(note that the 4.5 will be casted in 4).

\subsection{Array of Floats as a Term}
\node{Array of Floats as a Term}
\cpindex{Array of Floats as a Term}

A term can be an array of floats. Its C type in the Term structure is then \code{FLOAT\_ARRAY}. Arrays
of floats are read by the various programs of the \COPRSDE{} using the \samp{[}
and a matching \samp{]} square bracket. In this case, the type of the first
element determines the type of the whole array. If it is an \code{INTEGER}, then
the array is an \code{INT\_ARRAY}, if it is a \code{FLOAT}, then the array is a
\code{FLOAT\_ARRAY} (see above).  Any subsequent element is properly casted if
possible, if not it is set to 0.0.  The size of arrays read is the number of
element read. Arrays can be created/accessed/set with the appropriate evaluable
functions (\pxref{Array Manipulation Evaluable Functions}) and actions
(\pxref{Array Manipulation Actions}). Arrays can also be created/consulted
using the appropriate functions (\pxref{Array Manipulation Functions}).

Example of array of floats: \code{[ 1.5 4.2 4.0 5.888 0.0 3e4 3.1415]},
\code{[1.0 3.0 4 5.123 7123.123]} (note that the 4 will be casted in 4.0).


\subsection{C List as a Term}
\node{C List as a Term}
\cpindex{C List as a Term}

A term can be a C list. Its C type in the Term structure is then \code{OPRS\_LIST}. C lists are only
used when you want to return more then one value from an action, i.e.\ for a
multi variable special actions (\pxref{Multi Variable Special Action}). These
C lists are always lists of \code{Term *}. These lists look like composed terms,
or Lisp Lists, but they are not. They are not readable, although they are, to
some extend, printable.

Example of C lists, as you could build one to return from a multi variable
special action: \code{(1 2 3 nil foo (foo "asd" bar))}.

\subsection{Other Objects as Term}
\node{Other Objects as Term}
\cpindex{Other Objects as Term}

There are other objects which can be terms: \code{TT\_FACT}, \code{TT\_GOAL},
\code{TT\_INTENTION}, \code{TT\_OP\_INSTANCE}. These objects are manipulated by
the user but cannot be read from the parser as is.

\section{Special Symbols}
\node{Special Symbols}
\cpindex{Special Symbols}

There are a number of predefined symbols in the \CPK{}. These symbols can be
useful to the user to write evaluable functions (\pxref{Evaluable Functions})
or actions (\pxref{Using Action OPs}). They are defined in the file  \file{oprs-type-pub.h}.

\begin{verbatim}
extern Symbol lisp_t_sym;       /* The Lisp t symbol. */
extern Symbol wait_sym;         /* The :wait symbol. */
extern Symbol nil_sym;          /* The Lisp nil symbol */
\end{verbatim}

\begin{typevr}{Special Symbol}{extern Symbol}{lisp\_t\_sym}
is the \code{T} symbol as returned by evaluable functions and actions upon
success. 
\end{typevr}

\begin{typevr}{Special Symbol}{extern Symbol}{nil\_sym}
is the \code{NIL} symbol as returned by evaluable functions and actions upon
failure.  
\end{typevr}

\begin{typevr}{Special Symbol}{extern Symbol}{wait\_sym}
is the \code{:WAIT} symbol as returned by actions when they have not completed
their computation. 
\end{typevr}

\section{Frames and Binding Environments}
\node{Frames and Binding Environments}
\cpindex{Frames and Binding Environments}
\cpindex{Frames}
\cpindex{Binding Environments}

Frames (also called Binding Environments) are a very important component of the
unification mechanism. The reasons why this mechanism is important is of little
interest to the end user, however, it is important that the user be able to
``read'' and ``interpret'' such frame constructs. One has to remember that
frames give the binding of variables. Frames can be installed or not. When they
are installed, the variables are bound to the values specified by the frame.
Note that they can be bound to a value specified by another frame. As a
consequence, a variable cannot be bound in two different frames at the same
time.

A frame looks like this:
\begin{verbatim}
{ installed-boolean ( variables-binding ) previous-frame }
\end{verbatim}

Here is a real example commented:

\begin{verbatim}
{0              ; \r{it is not installed}
 ([{$Z->(Term *)NULL } >> C ]   ; \r{3 uninstalled bindings, $Z to C}
  [{$Y->(Term *)NULL } >> B ]   ; \r{$Y to B}
  [{$X->(Term *)NULL } >> A ] ) ; \r{$X to A}
 {              ; \r{The previous frame}
  1             ; \r{is installed,}
  ()            ; \r{but does not have any binding to install,}
  {}            ; \r{and point on the empty frame.}
 }
}
\end{verbatim}

\section{Properties}
\node{Properties}
\cpindex{Properties}

Properties are pairs: \code{(symbol term)}. Properties are used in OPs to handle
user-defined information which can be relevant to subsequent computation in
particular for meta level reasoning. For example, if you want to implement a
priority mechanism, then you can define a priority slot in the properties of
your OP and then write a meta level OP which, when necessary, will look in this
slot and intend the OP with the appropriate priority.  Note that we can have a
term which is evaluated at run time, if the function is an evaluable
function.

Example of properties: \code{(priority 12), (decision-procedure t),
(importance (+ 4 \$x))}.

\section{General Expressions}
\node{General Expressions}
\cpindex{General Expressions}

Expressions are used to represent facts in \COPRS{}.  General expressions
(gexpression) embed expressions and logical expressions (lexpression). Logical
expressions are just a combination of general expressions using the standard
logical operators.

General expressions (gexpression) are defined as follows:

\noindent
\code{gexpression := expression | lexpression} \\*
\code{lexpression := ( expr\_logical\_operator gexpression+ )} \\*
\code{expression := ( predicate term* ) | ( \~{} ( predicate term* ) )} \\*
\code{predicate :=  SYMBOL} \\*
\code{expr\_logical\_operator := \& | ||}

Example of gexpressions: \\*
\code{(foo a b)},\\*
\code{(factorial 5 120)},\\*
\code{(> 3 2)},\\*
\code{(\& (foo a \$x) (bar \$x 7))},\\*
\code{(\~{} (toto 45 (+ 3 4)))}.

\section{General Temporal Expressions}
\node{General Temporal Expressions}
\cpindex{General Temporal Expressions}


Temporal expressions (in short texpression) are used to represent goals in
\COPRS{}. A texpression is a gexpression with a temporal operator. General
temporal expressions (gtexpression) embed texpressions and logical temporal
expressions (ltexpression). Logical temporal expressions are just a combination
of general temporal expressions using the standard logical operators.

General Temporal Expressions (gtexpression) are defined as follows:

\noindent
\code{gtexpression := texpression | ltexpression} \\*
\code{ltexpression := ( texpr\_logical\_operator gtexpression+ )} \\*
\code{texpression := ( temporal\_operator gexpression )} \\*
\code{temporal\_operator := ! | ? | \^{} | \# | \% | => | \~{}> |}\\*
\code{                     achieve | test | wait | preserve |}\\*
\code{                     maintain | conclude | assert | retract}\\*
\code{texpr\_logical\_operator := \& | V}

According to the temporal operators, the gexpression contained is treated
differently.

The different temporal operators are the \dfn{achieve} operator, the \dfn{test}
operator, the \dfn{wait} operator, the \dfn{passive preserve} operator, the
\dfn{active preserve} operator, the \dfn{assert/conclude} operator and the
\dfn{retract} operator.

Example of gtexpression:\\*
\code{(! (factorial 5 \$x))},\\*
\code{(wait (tank full))},\\*
\code{(? (> \$x 5))},\\*
\code{(test (! (position valve close)) (\# (< (pressure-of tk1) 320)))}.

Note that not all gtexpressions have a defined associated semantics. We
shall see examples of such gtexpression at the end of this section.



\subsection{Achieve Operator}
\node{Achieve Operator}
\cpindex{Achieve Operator}

The achieve operator is represented with the symbol: \samp{!}, or with the
symbol \code{achieve} (in upercase or lowercase).

The semantics of this gexpression is to try anything ``possible'' to make the
gexpression true. Either it is already true in the database, if not and if any
OP is applicable to satisfy this goal, it will be attempted. If the OP executes
successfully, then the goal is achieved.

Example: \code{(! (position valve close))} is true of a sequence of states in
which the position of the valve is closed at the end. However, the kernel is
unable to handle goals such as: \code{(\& (! (position valve close)) (!
(pressure tk1 200)))}, because it does not know how to handle this type of
conjunction. However, a goal such as \code{(! (\& (position valve close)
(pressure tk1 200)))} may be achieved if \code{(\& (position valve close)
(pressure tk1 200))} is already true in the database. Last, \code{(\& (!
(position valve close)) (\# (pressure tk1 200)))} is allowed.

\subsection{Test Operator}
\node{Test Operator}
\cpindex{Test Operator}

The test operator is represented with the symbol: \samp{?}, or with the
symbol \code{test} (in upercase or lowercase).

The semantics of this gtexpression is to check if the gexpression is
currently true. Either it is already true in the database, or if any OP is
applicable to satisfy this goal, it will be attempted. If it is not true,
or cannot be achieved by the execution of a OP, it is considered as
failed.

Example: \code{(? (position valve close))} is true if and only if the valve is
currently closed. Note that this information may not be directly available in
the database, but may be concluded from other information, such as the fact
that two sensors agree on the fact that it is closed, or by calling an external
function to check it. In both cases, a OP responding to this particular goal
should be provided and would perform the appropriate computation. Note that as
for the achieve goal, the kernel is unable to handle goals such as: \code{(\&
(? (position valve close)) (? (pressure tk1 200)))}, because it does not know
how to handle this type of conjunction. However, a goal such as \code{(? (\&
(position valve close) (pressure tk1 200)))} may be achieved if \code{(\&
(position valve close) (pressure tk1 200))} is true in the database. In other
words, the database is able to handle conjunction and disjunction, but not the
OP retrieval mechanism. This problem can be solved using multi thread
execution (by putting each goal on a separate thread).

\subsection{Wait Operator}
\node{Wait Operator}
\cpindex{Wait Operator}

The wait operator is represented with the symbol: \samp{\^{}}, or with the
symbol \code{wait} (in upercase or lowercase).

The semantics of this gtexpression is to wait until the gexpression becomes
true. Either it is already true in the database, or the kernel waits until it
becomes true by putting the intention or task, from which this goal comes from,
to sleep.  Note that this goal never fails\dots{} The intention or thread
sleeps until it becomes true, so at worst, the intention sleeps forever.

Example: \code{(\^{} (position valve close))} will always return true. It is just
a matter of when it will return. The kernel will suspend the thread executing
this goal until the condition is satisfied, so it can never fail (but it can
remain suspended for ever too). Waiting goals are often combined to make
watchdog, such as: \code{(\^{} (|| (position valve close)) (elapsed-time (time)
10))}, which will wait until either the valve is closed or 10 seconds elapsed.
Note that there are no way to know which condition satisfied, but usually it is
just a matter of putting a test after this goal to check which condition is
true or not.

\subsection{Passive Preserve Operator}
\node{Passive Preserve Operator}
\cpindex{Passive Preserve Operator}

The preserve operator is represented with the symbol: \samp{\#}, or with the
symbol \code{preserve} (in upercase or lowercase).

The semantics of this operator is to preserve the truth of the
gexpression. This is a passive preservation, i.e.\ when the gexpression
becomes false, automatically, this goal and presumably any conjunction of
goals it is part of is considered as failed.

Example: The passive preserve operator is never used alone, it is always used in a
conjunction such as in: \code{(\& (! (position valve close)) (\# (pressure tk1
200)))} which will attempt to close the valve while checking that the pressure
in \code{tk1} remains equal to \code{200}. Note that the passively preserved
condition are checked continuously (as new events are received by the system).
Moreover, if the preserved condition fails, the conjunction fails. It is then
up to the user to figure out what went wrong and take any appropriate action
accordingly.

\subsection{Active Preserve Operator}
\node{Active Preserve Operator}
\cpindex{Active Preserve Operator}

The active preserve operator is represented with the symbol: \samp{\%}, or with the
symbol \code{maintain} (in upercase or lowercase).

The semantics of this operator is to actively preserve the truth of the
gexpression. This is an active preservation, i.e.\ when the gexpression
becomes false, the system tries automatically to re-achieve it by
invoking a OP which has this goal in its invocation part. When the condition is
failed, the execution thread in which this goal appears is stopped and the
system will try to reachieve the condition.

Example: The active preserve operator is never used alone, it is always used in a
conjunction such as in: \code{(\& (! (position valve close)) (\% (pressure tk1
200)))} which will attempt to close the valve while checking that the pressure
in \code{tk1} remains equal to \code{200}. Note that the passively preserved
condition are checked continuously (as new events are received by the system).
Moreover, if the preserved condition fails, the kernel will attempt to
reestablish it by calling a OP which match this active preserve goal. If all
attempts to reestablish the fail condition fail, then the conjunction is failed.

\subsection{Assert/Conclude Operator}
\node{Asssert/Conclude Operator}
\cpindex{Conclude Operator}
\cpindex{Assert Operator}

The conclude operator is represented with the symbol: \samp{=>}, or with the
symbol \code{conclude}, or with the symbol \code{assert} (in upercase or
lowercase).

When executed, this goal has for effect to assert the gexpression in the
database. To do so, the gexpression is transformed as a fact and is pushed
into the kernel (and can lead to OP execution). This goal always succeeds.

Example: \code{(=> (position valve close))}. One can also put more then one
conclude or retract goal in a conjunction: \code{(\& (=> (position valve close))
(=> (pressure tk1 200)) (\~{}> (ALARM))))}.

\subsection{Retract Operator}
\node{Retract Operator}
\cpindex{Retract Operator}

The retract operator is represented with the symbol: \samp{\~{}>}, or with the
symbol \code{retract} (in upercase or lowercase).

When executed, this goal has for effect to retract the gexpression from the
database. It always succeeds.


Example: \code{(\~{}> (position valve close))}. One can also put more then one
conclude/assert or retract goal in a conjunction: \code{(\& (\~{}> (position valve
close)) (\~{}> (pressure tk1 200)) (\~{}> (ALARM))))}.

\section{General Meta Expressions}
\node{General Meta Expressions}
\cpindex{General Meta Expressions}

A general meta expression (gmexpression) is defined as follows:

Gmexpressions are mainly used in \dfn{invocation part} and other OP text
fields. There is no real reason for them to exist under this form, and they are
provided, as is, more for upward compatibility with SRI Lisp \OPRS{} than for
real syntactic reasons. The parser has been modified to allow directly
gexpressions and gtexpressions. The parser does nore recognizes the old
\code{*FACT} and \code{*GOAL} markers (\pxref{Principal Differences with SRI PRS}).

\noindent
\code{gmexpression := mexpression | lmexpression} \\*
\code{lmexpression := ( mexpr\_logical\_operator gmexpression+ )} \\*
\code{mexpression :=  gexpression | gtexpression } \\*
\code{mexpr\_logical\_operator := AND | OR | NOT}



\subsection{FACT Meta Expressions}
\node{FACT Meta Expressions}
\cpindex{FACT Meta Expressions}

The FACT Meta Expressions are used to designate a gexpression in the OP
applicability fields.

Example of FACT Meta Expressions:\\*
\code{(FOO a b)},\\*
\code{(> 4 3)},\\*
\code{(foo 32 "this is a string")},\\*
\code{(elapsed-time (time) 32)}.

\subsection{GOAL Meta Expressions}
\node{GOAL Meta Expressions}
\cpindex{GOAL Meta Expressions}

The GOAL Meta Expressions are used to designate a gtexpression in the OP
applicability fields.

Example of GOAL Meta Expressions:\\*
\code{(? (bar a b))},\\*
\code{(! (factorial \$x \$y))},\\*
\code{(? (> 3 4))},\\*
\code{(\^{} (elapsed-time (time) 10))}.

\section{Facts}
\node{Facts}
\cpindex{Facts}

Facts are gexpressions concluded in the system. For example, the effects part
of a OP is a list of Texpressions (only conclude and retract operator). Each of
the concluded Gexpressions (only Expressions) is concluded in the system as a
new fact. However, facts contain much more information than just the
gexpression from which they originate. For example they keep track of various
dates, like their creation date, or the date at which they have been completely
parsed by the applicable OP mechanism (\pxref{Fact and Goal Manipulation Functions}).

Facts, as opposed to goals, are not linked in any way to the procedure,
intention or external module they come from. Facts are perfectly anonymous in
the sense that they are just a piece of information which is concluded in the
database and which may start some procedures. However, if a fact is a message,
then its data structure stores the module from which it originated.
Nevertheless, for any fact or message, the success or failure of the procedures
applicable because of them is of no interest to anybody (i.e.\ any
OP or intention)\dots{}

Facts cannot contain any unbound variable. They would be meaningless as
these facts are not associated with any binding environment.

\section{Messages}
\node{Messages}
\cpindex{Messages}

Messages are facts. They are called messages because they come from ``outside''
(presumably from a different agent such as another \CPK{} or an external
program such as a monitor). Moreover, they usually come on the \MPA{} socket. As
soon as they are received by the \CPK{}, they are treated as Facts. When
received, the message contains the name of the sender, and if the appropriate
trace flag is on, a message on the screen advises you of the arrival of the
message as well as of the name of the sender. This information is kept in the
fact which will be created from the message, and can be retrieved with the
appropriate access function (\code{fact\_sender}, \pxref{Fact and Goal Manipulation Functions}).

\section{Goals}
\node{Goals}
\cpindex{Goals}

Goals (as opposed to facts) are linked to an already existing and executing
procedure and intention (the intention in which this procedure executes).  They
can contain unbound variables, which are often used to return values.  For
example, when the goal: \code{(! (factorial 4 \$X))} is posted, you most likely
expect the \code{\$X} to be bound to 24 upon success of this goal.

Although it is technically possible, it is contrary to \OPRS{} philosophy to
post a goal in a kernel. Goals should only come from the execution of
procedures. An agent usually does not directly give a goal to another agent. It
merely passes a message containing a request to achieve a goal, in which case a
message, i.e.\ a fact, is passed to the \CPK{}.  Moreover, if you directly post
a goal from the ``keyboard'' you may lose it, if the applicable OP selection
mechanism does retain its OP Instance for execution (if the goal is posted by
the kernel, it will be automatically reposted until failure or success).

\chapter{OP Syntax and Semantics}
\node{OP Syntax and Semantics}
\cpindex{OP Syntax and Semantics}
\cpindex{OP Syntax}
\cpindex{OP Semantics}

OPs must follow a very rigorous syntax. The \OPE{} and the \CPK{} will
enforce this syntax as much as possible. As a matter of fact, any OP
properly parsed by the \OPE{} should be parsed and compiled (for the
syntax part) without any problem by the \CPK{}.

OPs are composed of two parts. A number of text fields which define the
``declarative'' part of the procedure, and the Graph part (in some OPs, it is
just an action), which defines the operative or the procedural part of the OP.
The declarative part is composed of various fields. Three of these fields are
controlling the applicability of the OP, the \dfn{invocation part}, the
\dfn{context part}, and the \dfn{setting part}. To be applicable, these three
parts must be true, but in a different way.



\section{OP Applicability Fields}
\node{OP Applicability Fields}
\cpindex{OP Applicability Fields}

The applicability fields are the field controlling the applicability of the OP.
They are: the invocation part, the context part, and the setting part. For a OP
to be applicable, these three fields must be true in the same binding
environment. However, each field has a particular semantics, which should be
respected to take full advantage of \COPRS{} OP triggering mechanism. The
invocation part is a logical expression describing the \dfn{events} that must
occur for the OP to be executed. Usually, these consist of some \dfn{changes}
in system goals (in which case, the OP is invoked in a goal-directed fashion)
or system beliefs (resulting in data-directed or reactive invocation), and may
involve both. The context part is a logical expression specifying those
conditions that must be true of the current state for the OP to be executed.
The setting part is a logical expression specifying conditions that must be
true, but for which the truth value can be determined before the system runs
(after the database and the OP have been loaded). In other words, the conditions
appearing in the setting part are not run-time dependent. One can see that this
separation between the invocation part, the context part, and the setting part
is only justified by performance and efficiency reasons.



\subsection{Invocation Part}
\node{Invocation Part}
\cpindex{Invocation Part}

The Invocation part is a General Meta Expression (\pxref{General Meta
Expressions}). It specifies which facts, goals or any combination of both can
trigger the applicability of a OP. Keep in mind that only the facts
and goals specified in the invocation part can trigger the OP applicability. In
other words, a OP is considered relevant, i.e.\  considered for applicability,
only if the system has a new goal or a new fact which is specified in
the invocation part of this OP. Note that for this reason there is no point at
all in putting an evaluable predicate in the invocation part of a OP.

Example of invocation part: \\*
\code{(ALARM)}, \\*
\code{(position \$x BP)}, \\*
\code{(OR (ALARM) (FIRE))}, \\*
\code{(AND (ALARM) (OVERPRESSURIZED \$TANK))}.

\subsection{Context Part}
\node{Context Part}
\cpindex{Context Part}

The Context part is either a General Meta Expression (\pxref{General Meta Expressions}), or nothing.

It contains information which must be true for the OP to be applicable, but the
difference with the invocation part is that the occurrence of this information
does not trigger the OP applicability.

Example of context part: \\*
\code{(POSITION \$T \$POS)}, \\*
\code{(> \$X 245)}, \\*
\code{(OR (FOO \$x) (BAR \$Y))}, \\*
\code{(AND (POSTION \$T OPEN) (STATUS \$T GOOD))}.

\subsection{Setting Part}
\node{Setting Part}
\cpindex{Setting Part}

The Setting part is either a General Meta Expression (\pxref{General Meta Expressions}), or nothing.

It contains information which must be true to make the OP applicable, but
this information is not supposed to change over time. In other words, the
truth value of this part (or more accurately, the frames in which this
gmexpression is true) can be defined at OP compile time (providing the
fact database is loaded).

Example of setting part: \\*
\code{(CONNECTED \$PIPE \$TANK)}, \\*
\code{(ASSOCIATED-SENSORS \$S1 \$S2)}, \\*
\code{(OR (ASSOCIATED-SENSORS \$S1 \$S2) (ASSOCIATED-SENSORS \$S2 \$S1))}, \\*
\code{(AND (ASSOCIATED-XDCR \$TK1 \$XDR1) (ASSOCIATED-XDCR \$TK2 \$XDR2))}.

\section{OP Other Fields}
\node{OP Other Fields}
\cpindex{OP Other Fields}

Other fields used in OP include:


\subsection{Effects Part}
\node{Effects Part}
\cpindex{Effects Part}

The Effects part is either a list of General Temporal Expressions
(\pxref{General Temporal Expressions}), or nothing.

It contains a list of conclude or retract texpressions which are
concluded or retracted upon successful execution of the OP.

Example of effects part: \\*
\code{()}, \\*
\code{((=> (POSITION \$T \$POS)))}, \\*
\code{((\~{}> (POSITION \$T \$POS)))}, \\*
\code{((=> (POSITION \$T1 \$POS1))
(=> (POSITION \$T2 \$POS2))
(=> (POSITION \$T3 \$POS3)))}, \\*
\code{((\~{}> (FOO \$x))
(=> (FOO \$y))
(=> (BAR \$X \$Y)))}.

\subsection{Properties Part}
\node{Properties Part}
\cpindex{Properties Part}

Important properties of the OP are represented in the properties slot. The
Properties part is either a list of properties (\pxref{Properties}), or
nothing. It contains a list of properties which can be used by the appropriate
predicates (\pxref{OP Instance Related Evaluable Predicates} and functions
\pxref{OP Instance Related Evaluable Functions}). Properties are usually used
by meta level OP (\pxref{OP Properties}) to retrieve specific information about OPs.

Example of properties part: \\*
\code{()}, \\*
\code{((DECISION-PROCEDURE T))}, \\*
\code{((ID FOO))}, \\*
\code{((RESOURCE-USED PLATINE))}, \\*
\code{((SPEED (evaluate-speed \$x \$y \$z)) (RELIABILITY 23))}, \\*
\code{((PRIORITY \$X))}.

\subsection{Documentation Part}
\node{Documentation Part}
\cpindex{Documentation Part}

The Documentation is a string. Its purpose is to document the OP.

Example of documentation part: \\*
\code{""}, \\*
\code{"This string document the OP."}, \\*
\code{"You can put variable names such as \$x in documentation strings."},
\\*
\code{"This OP will kill its own intention after 10 seconds. 10, 9, 8,
7, 6, 5, 4, 3, 2, 1... Ophbooum..."}, \\*
\code{"This is a test OP. Please ignore."}.

\section{Execution Part}
\node{Execution Part}
\cpindex{Execution Part}

There are two different types of OPs in \COPRS{}. Action OPs are the
basic or low level actions of the system, and Graph OPs are the real
procedures or plans of the system.



\subsection{Graph OP}
\node{Graph OP}
\cpindex{Graph OP}

The body of a OP is represented as a graphic network and can be viewed as a
plan or plan schema. Each arc of the network is labelled with a goal.

\figuregif[scale=0.5]{move-valve-op-new}{Another Example of a OP}{fig-procfig-new}

A typical example of a OP is given in Figure \ref{fig-procfig-new}, which
describes a procedure to isolate close a valve in the truck demo presented in
\xref{Truck Loading Example}. The invocation part describes useful 
conditions for this OP. In this case, the OP is considered useful
whenever the system acquires the goal to close or open a valve, provided the
various facts given in the context part are true.  (In determining the truth
value of the invocation part, some of the variables appearing in the invocation
part will be bound to specific identifiers. Indeed, in this case, all the time
out values will be so bound.)


\figuregif[scale=0.5]{move-valve-op-exp}{An Example of a OP}{fig-procfig}

Figure \ref{fig-procfig-new} presents an older version of this OP. The OP body
describes what to do if the OP is chosen for execution.  Execution begins at
the \code{start} node in the network, and proceeds by following arcs through
the network. Execution completes if it reaches a finish node (a node with no
exiting arcs). If more than one arc emanates from a given node, any one of the
arcs emanating from that node may be traversed. To traverse an arc, the system
must either (1) determine from the database that the goal has already been
achieved or (2) find a OP (procedure) that achieves the goal labelling that
arc. For example, to cross the arc emanating from the start node requires
either that the system has already flipped the switch or that some OP to do it
be successfully executed. If the system fails to go through an arc emanating
from some node, other arcs emanating from that node may be tried.  If, however,
the system fails to achieve any of the goals on arcs emanating from the node,
the OP as a whole will fail. For instance, since only one arc emanates from the
\code{START} node in Figure \ref{fig-procfig}, if all attempts to flip the
switch fail, this procedure for opening or closing the valve will also fail.

\subsection{New Graph OP Construction}
\node{New Graph OP Construction}
\cpindex{New Graph OP Construction}

There are some new graph construction
allowed in \COPRSDE{}: the ``IF-THEN-ELSE'' node; to express conditional branching, and the
``split'' and ``join'' node; to express parallel execution. These two new
constructions are presented in the next sections.



\subsubsection{IF-THEN-ELSE Node}
\node{IF-THEN-ELSE Node}
\cpindex{IF-THEN-ELSE Node}

The ``IF-THEN-ELSE'' node was introduced in \COPRS{} to simplify the
construction of OPs. To illustrate this we show a OP written the old way, and
then the same one with the new way.

\figuregif[scale=0.5]{rec-fact}{A OP to Compute Factorial Recursively (Old if-then-else Form).}{rec-fact-op}

The OP shown on Figure \ref{rec-fact-op} computes factorial recursively.
One can see that the OP starts with a test to check if \code{\$n} is either
greater than \code{1} or smaller.

\figuregif[scale=0.5]{rec-fact-ite}{A OP to Compute Factorial Recursively (New if-then-else Form).}{rec-fact-ite-op}

The OP shown on Figure \ref{rec-fact-ite-op} performs exactly the same
operation: computes factorial recursively. However, one can see that the OP
\code{S1} and \code{S3} nodes have been replaced by a \code{N0} node which is
surrounded by two nodes labeled \code{T} and \code{F}. This node \code{N0} is
a ``IF-THEN-ELSE'' node. It works as follows: when an edge as an
``IF-THEN-ELSE'' outgoing node, the goal labeling this edge never fail. In
other words, the transition is always possible. If the goal is achieved (in our
example if the goal \code{(? (<= \$n 1))} is true), then the execution proceeds
from the \code{T} node, otherwise, it proceeds from the \code{F} node. This
construction is in fact very similar to the old \dfn{test-and-set} construction
(\pxref{Miscellaneous Actions}).

\figuregif[scale=0.5]{op-ite-fact}{A OP to Compute Factorial Iteratively (Old if-then-else Form).}{ite-fact-op}

\figuregif[scale=0.5]{op-ite-fact-if-then-else}{A OP to Compute Factorial Iteratively (New if-then-else Form).}{ite-fact-ite-op}

Figure \ref{ite-fact-op} and Figure \ref{ite-fact-ite-op} show another example
of an old form and a new form of procedure.

Apart from the visual aspect, this ``IF-THEN-ELSE'' construction is also more
efficient as you will evaluate less goals (1 goal instead of 1.5 goal in average).

\subsubsection{Split and Join Node}
\node{Split and Join Node}
\cpindex{Split and Join Node}

The split and join node is a construction which is linked to the use of
parallel execution (\pxref{Parallel Execution of OPs in OPRS}).

\figuregif[scale=0.5]{op-fib}{A OP to compute Fibonacci (without parallelism).}{fib-op}

\figuregif[scale=0.5]{op-fib-par}{A OP to compute Fibonacci (with parallelism).}{fib-par-op}

Here also we illustrate this new construction with concrete examples.
Figure \ref{fib-op} shows a OP which computes Fibonacci. In this particular
case, the two recursive calls can be done in parallel. Figure \ref{fib-par-op}
shows an example of such construct. In this particular example we mixed the
``IF-THEN-ELSE'' construction with the split node. The \code{F} node of the
\code{N0} ``IF-THEN-ELSE'' node is a split node (this is represented with the
thick bottom of the node). Similarly, the \code{S4} node is a join node.
Basically, a split node split as many thread as it has outgoing edges, and a
join node merge as many thread as they are ingoing edges. \xref{Parallel Execution of OPs in OPRS} for more on this subject.

\subsection{Action OPs}
\node{Action OPs}
\cpindex{Action OPs}

Some OPs have no bodies.  These are the primitive OPs of the system and
are associated to a primitive action that is directly
performable by the system.  Clearly, execution of any OP must eventually
reduce to the execution of sequences of primitive OPs (unless, of
course, each of the subgoals of the OP has already been achieved).

There are two types of action OPs. They correspond to 2 types of behavior.
With Standard Action, you expect the performed action to return a symbol
(usually \code{T}, \code{NIL} or \code{:WAIT}, see \nxref{Important Variables},
and \nxref{Special Symbols}) to inform the system of the success or the
failure of the execution. However, in many application one want to grab the
value(s) returned by the action and eventually bind it/them or unify it/them
with a variable or a list of variables, this is the role of the Special Action
and Multi Variable Special Action. Last, not least, in both cases, the action
can return before completion (there is a special value \code{:WAIT} for this
purpose) and will be automatically called again after the system has checked
for new applicable OPs (\pxref{Action Slicing}).



\subsubsection{Standard Action}
\node{Standard Action}
\cpindex{Standard Action}

\figuregif[scale=0.5]{action-op}{A Standard Action OP}{stand-act-op}

The standard action is a \dfn{Composed Term} (see Figure
\ref{stand-act-op}).  The function part of this composed term must be
declared as an action (\pxref{How to Define your Own Actions}). The value
returned by the evaluation of this function is meaningful. It must be a
pointer to term, and this term will be freed by the caller. If it returns
the term symbol \code{:wait}, the function has not completed its execution
and it should be called again later.  If it returns the term symbol
\code{NIL}, then the action is considered as failed and the OP failed the
goal it was working on. Any other term value returned is considered as a
success, and the action OP is successful.

Example of standard action: \code{(print \$x)}, \code{(send-message \$x
\$y)}, \code{(init-robot)}, \code{(goto-location \$x \$y)}.

\subsubsection{Special Action}
\node{Special Action}
\cpindex{Special Action}

Special actions are provided to allow the binding of the result from the
action evaluation. Their syntax is different (see Figure
\ref{special-act-op}). A special action must be of the following form: \\*
\code{(*=* <variable> <composed-term>)}.

\figuregif[scale=0.5]{special-action-op}{A Special Action OP}{special-act-op}

Here also, the function part of the composed term must be an action
(\pxref{Using Action OPs}) or an evaluable function (\pxref{Evaluable Functions}).  The only difference with standard action is that the result
of the evaluation is unified with the variable. The success or the failure
of the OP itself depends on the result of the unification. If the
unification succeeds, then the OP is considered as successful, it is a
failure otherwise. Note that if the action returns the term symbol:
\code{:WAIT}, the action will be called again later.

Example of special action: \code{(*=* \$y (read))}, \code{(*=* \$status
(init-system \$y))}, \code{(*=* T (confirm \$y))}.

\subsubsection{Multi Variable Special Action}
\node{Multi Variable Special Action}
\cpindex{Multi Variable Special Action}

\figuregif[scale=0.5]{multi-special-action-op}{A Multi Variable Special Action OP}{multi-special-act-op}

One can bind a list of terms/variables to a list of
terms returned by an action (see Figure \ref{multi-special-act-op}).

The newly allowed form for special action is thus: \\*
\code{(*=* (<variable>*) <composed-term>)}.\\*
The old form remains valid. The behavior is exactly the same, except that
the action is expected to return a list of terms. Each term will be
unified against the corresponding term/variable in the list. If the number
of terms differ (i.e.\ there are two variables in the list and the action
returns three terms), or if one of the unification fails, the action
fails. Note that if the action returns the term symbol \code{:WAIT}, the
action will be called again later.

Example of multi variable special action:\\*
\code{(*=* (\$x \$y \$theta) (position robot))},\\*
\code{(*=* (\$result \$status) (init-system \$y))}.

Example of a form which is not a multi variable special action (it must be a
list of variables, not terms):\\*
\code{(*=* (T NIL T) (confirm-three-responses \$y \$z \$w))}.

%One can find an example of an action returning a list of terms in the
%file: \file{user-action.c}.

\subsection{Text OPs}
\node{Text OPs}
\cpindex{Text OPs}

Text OPS have been introduced in recent versions of \COPRS{} to allow user to
write OP as standard programing language. Text OPs language provide standard
if-then-else, while, do-while, goto, break construct, as well as parallel
operator.  \xref{Grammar Used in the OPRS Development Environment} for a
description of this grammar. Like action OP and graphic OP, they can be traced.



\subsubsection{General Presentation of the Text OPs}
\node{General Presentation of the Text OPs}
\cpindex{General Presentation of the Text OPs}

The best way to illustrate text OPs is to study some examples.

The following file presents text OPs which implement factorial.
\smallverbatimfile{fact-text.txt-opf}


\figuregif[scale=0.5]{op-meta-fact-text}{Meta Factorial Text OP}{text-op}

The OP on Figure \ref{text-op} is the \OPE{} representation of the \code{Meta
Factorial} presented above.

The following file presents text OP which implement fibonacci.
\smallverbatimfile{fib-text.txt-opf}

\figuregif[scale=0.5]{op-fib-text}{Fibonacci Text OP}{fib-text-op}

The OP on Figure \ref{fib-text-op} is the \OPE{} representation of the
\code{Fibonacci} presented above.

Text OPs  are editable with the op-editor, but can also be created with your
preferred text editor. In fact, the op-editor does not store any position, nor
text filling information about these OPs and will not allow you to move the
fields of a text OP. 

One can mix graph op and text OP in the same OP file. Text OPs are put in OP
file with  the same extension file \file{.opf}. As long as all the OPs in a OP
files are text OPs you can edit this file emacs or your prefered text editor.
However if  at least one OP in a OP file is a graphic OP, then you can  still
grab or edit the text OP in this file, but it is more difficult, and it is at
your own risk.

The body field of a text OP cannot be empty... it must at least contain the
empty instruction list, i.e.\ \code{()}.

Actions OP created under the OP Editor are by default considered as graphic OP.

There is one major advantage in editing text OP in the \OPE{}, the lexical and
syntaxic parsing is continuously done.  Otherwise, if you edit them under
Emacs, you will have to wait until you load them in the OP-Editor or OPRS to
check them.

Text OP selected for graphic trace, show up on the screen, and you can see the
body, the other interesting fields, adn hilighted the currently posted goals.

\subsubsection{IF-THEN-ELSE Instruction}
\node{IF-THEN-ELSE Instruction}
\cpindex{IF-THEN-ELSE Instruction}

The \code{IF-THEN-ELSE} instruction and \code{IF-THEN-ELSEIF}...  instructions
are standard branching operations.

The syntax is the following:
\begin{verbatim}
if_inst: ( IF if_part_inst )

if_part_inst: gtexpr list_inst
        | gtexpr list_inst ELSE list_inst
        | gtexpr list_inst ELSEIF if_part_inst
\end{verbatim}

list\_inst is a possibly empty sequence of instruction.

here is an example of use:
\begin{verbatim}
(IF (? (PREFER-ITERATIVE))
    ;;; Look for the one which has property recursive
    (IF (? (PROPERTY-P RECURSIVE (FIRST $X)))
       (! (INTENDED-OP (SECOND $X)))
     ELSE
       (! (INTENDED-OP (FIRST $X)))
    )
  ELSEIF (? (PREFER-RECURSIVE))
    ;;; Look for the one which has property recursive
    (IF (? (PROPERTY-P RECURSIVE (FIRST $X)))
       (! (INTENDED-OP (FIRST $X)))
     ELSE
       (! (INTENDED-OP (SECOND $X)))
    )
  ELSE
    ;;; We do not have any preference... 
    ;;; Choose randomly
    (! (INTENDED-OP (SELECT-RANDOMLY $X)))
    (! (PRINT "Intending randomly"))
 )
\end{verbatim}

\subsubsection{WHILE Instruction}
\node{WHILE Instruction}
\cpindex{WHILE Instruction}


The \code{WHILE} instruction is a standard while operations.

The syntax is the following:
\begin{verbatim}
while_inst: ( WHILE gtexpr list_inst )
\end{verbatim}

list\_inst is a possibly empty sequence of instruction.

here is an example of use:
\begin{verbatim}
(WHILE (? (> @TMP 1))
    (! (= @RES (* @RES @TMP)))
    (! (= @TMP (- @TMP 1)))
 )
\end{verbatim}

One can use the \code{BREAK} instruction to make a local exit of the while
loop.

\subsubsection{DO-WHILE Instruction}
\node{DO-WHILE Instruction}
\cpindex{DO-WHILE Instruction}

The \code{DO-WHILE} instruction is a standard do-while.

The syntax is the following:
\begin{verbatim}
do_inst: ( DO list_inst WHILE gtexpr )
\end{verbatim}

list\_inst is a possibly empty sequence of instruction.

here is an example of use:
\begin{verbatim}
(DO 
 (! (FOO $X))
 (// ( (! (BAR $Y)) (! (BOO $Z)))
     ( (! (BAR $A)) (! (BOO $W)))
     ( (! (BAR $B)) (! (BOO $U)))
 )
 WHILE (? (> (X-OF $Y) 35)))
\end{verbatim}

Here also, one can use \code{BREAK} to exit the loop.

\subsubsection{Parallel Instruction}
\node{Parallel Instruction}
\cpindex{Parallel Instruction}

The \code{//} instruction executes all the branches in parallel.

The syntax is the following:
\begin{verbatim}
par_inst: ( // <par_list_inst>* )

par_list_inst: ( list_inst )
\end{verbatim}

list\_inst is a possibly empty sequence of instruction.

here is an example of use:
\begin{verbatim}
 (// ((! (= @TMP $N))
      (! (=@FOO @TMP))
     )
     ((! (= @RES 1))
     )
 )
\end{verbatim}

\subsubsection{GOTO-LABEL Instruction}
\node{GOTO-LABEL Instruction}
\cpindex{GOTO-LABEL Instruction}


The \code{GOTO-LABEL} instruction is a standard goto operations.

The syntax is the following:
\begin{verbatim}
goto_inst: GOTO id

label_inst: LABEL id
\end{verbatim}

here is an example of use:
\begin{verbatim}
(;;; comment
 LABEL test
 (! (foo @x))
 (! (= @x (- @x 1)))
 (IF (? (> @x 0))
     GOTO test
  ELSE
     GOTO fin)
  LABEL fin
)
\end{verbatim}

\subsubsection{Comment Instruction}
\node{Comment Instruction}
\cpindex{Comment Instruction}

Although if is not really an instruction, comments can only be used and
presented while they are present in an instruction position. As noted on the
examples above, comments are presented with one or more semicolon \samp{;} in
instructions sequences.

\section{Procedure and Expression Compilation and Parsing}
\node{Procedure and Expression Compilation and Parsing}
\cpindex{Procedure and Expression Compilation and Parsing}
\cpindex{Procedure Compilation}
\cpindex{Procedure Parsing}
\cpindex{Expression Compilation}
\cpindex{Expression Parsing}

Before being executed, procedures are compiled. This is done
automatically when you load a OP file in \aCPK{}. Most of the time, this
compilation goes without any problem (because procedures have been
created with the \OPE{} which is fairly rigorous regarding the syntax
allowed for a OP). However, one could imagine that, for some reason, a OP
may not be parsable by the \CPK{} and could be rejected by the OP compiler.

In any case, the OP compiler does more than just syntax checking. Some
semantic checking is done too. For example, it can check that all the
symbols you use have been declared. It can also check that the actions
which appear in the action part of an Action OP are indeed declared as
evaluable functions. The compilation and syntax checking does not only apply to
procedure themeselves, but also to expression parsed by the kernel.



\subsection{Action Checking}
\node{Action Checking}
\cpindex{Action Checking}

If a symbol is considered to be associated to an action definition
(because it appears as an action call in an action part of a OP), then
the system will check that such action has been defined (linked) in the
kernel. A warning will be issued if no definition can be found for this
action. Special action can be defined as evaluable functions too. In other
words, if you have declared the function \code{FOO} as an evaluable
function, you can call it in place of a special action. The system will also
check that the number of arguments of the call is consistent with the number of
arguments of the declaration.

Part of this checking can be turned on or off using the \code{set action
on|off} command (\pxref{OPRS Kernel Compiler/Parser Option Commands}).

\subsection{Predicate Checking}
\node{Predicate Checking}
\cpindex{Predicate Checking}

Predicates are also subject to some checking at parsing time. First, if the
predicate checking is on, then the system will check that the predicate has
been declared before its first occurrence in an expression. Predicate can be
declared with a \code{declare predicate} command or one of the \code{declare
ff}, \code{declare be}, \code{declare op\_predicate}. Note that an evaluable
predicate is automatically declared (\pxref{OPRS Kernel Declaration Commands}). This predicate checking can be turned on or off using the \code{set
predicate on|off} command (\pxref{OPRS Kernel Compiler/Parser Option Commands}). Moreover,
the number of arguments of predicates is now fixed. Therefore, whenever the
system encounters a predicate for the very first time, it will set its number
of argument and will then check that subsequent use of this predicate is done
with the same number of argument.

\subsection{Function Checking}
\node{Function Checking}
\cpindex{Function Checking}

Functions are also subject to some checking at parsing time. First, if the
function checking is on, then the system will check that the function has been
declared before its first occurrence in an expression. Function can be declared
with a \code{declare function} command. Note that an evaluable function is
automatically declared (\pxref{OPRS Kernel Declaration Commands}).  This
checking can be turned on or off using the \code{set function on|off} command
(\pxref{OPRS Kernel Compiler/Parser Option Commands}).

\subsection{Symbol Checking}
\node{Symbol Checking}
\cpindex{Symbol Checking}

While compiling OP and parsing expresion, the system will check for new
symbol. In other words<, if it encounters a symbol for the first time, a warning
will be displayed to inform the user of this newly used symbol. This facility
can be disabled but it is usually very useful to catch typos... Nevertheless,
it is advised to create a symbol file, (containing \code{declare id} commands for
each symbol you want to declare in your application). Note that all symbols
declared by other means. 

This checking can be turned on or off using the \code{set symbol on|off}
command (\pxref{OPRS Kernel Compiler/Parser Option Commands}).

\chapter{Database}
\node{Database}
\cpindex{Database}

The content of the OPRS database represents the current beliefs of the
system. Some of these beliefs are provided initially by the system user.
Typically, they include facts about static properties of the application
domain, such as the structure of some subsystems or the physical laws that
must be obeyed by certain mechanical components. Other beliefs are derived
by \COPRS{} itself as it executes its OPs. They are typically current
observations about the world or conclusions derived by the system from
these observations, and they may change over time. For example, at some
times \COPRS{} may believe that the pressure of a tank is within acceptable
operating limits, at other times not. Updates to the database therefore
necessitate the use of consistency maintenance techniques.

The database is one of the most important components of the \CPK{}.
Its role is basically to ``remember'' which expressions or
evaluable predicates are true and, to give the expressions back upon
consultation. This consultation can be done by the user with
a \code{consult} command (\pxref{OPRS Kernel Database Commands}), or
by the kernel itself when it tries to execute a procedure
(\pxref{Procedure Execution and Run Time}).

On top of these basic functionalities, several related
functionalities are provided by the database and are very often
critical in the application using \COPRS. They are all presented in this
chapter.

The database uses a term indexing mechanism \cite{Stieckel}, which has
been extended in various ways to handle some specific operations, and allows
consultation in constant time.



\section{Database File Format}
\node{Database File Format}
\cpindex{Database File Format}

The internal format of the database is of no interest to the end user.
However, a user may need to load a certain number of facts at once. This can be
done by issuing a series of \code{conclude} commands (\pxref{OPRS Kernel Database Commands}), but this can be rather tedious\dots{} More easily, this
can be done by loading a database file (\pxref{OPRS Kernel Loading Commands}).

The database file format is rather simple. It is a list of expressions. As in
Lisp, any line starting with a semicolon \samp{;} is considered as a comment.

Here is an example of such a file:
\begin{verbatim}
;;; This is a comment
(
(foo a b)
(bar 23 (+ 4 5))
(boo (f g h) "this is a string" 23.44)
(foo a c)
(bar 3 (+ 74 5))
(foo (f g h) "this is a string" 23.44)
(fo a b)
(ba 23 (+ 4 5))
(bo (f g h) "this is a string" 23.44)
)
\end{verbatim}

It is recommended to use the \file{.db} extension for these database files.

Note that you need to declare any closed world predicate and functional
fact before you load a database containing facts referring to them.
Evaluable functions and predicates are defined beforehand in the kernel at
link time, so no precaution has to be taken for them.

\section{Unification}
\node{Unification}
\cpindex{Unification}
\cpindex{Unification}

Although not specific to the database, the unification used in the \CPK{} is
mostly used in database operations (but not only in database operations). For
example, when you consult an expression such as \code{(foo \$x 6)}, then at some
point the \code{\$x} variable may be unified to a term if necessary.

The unification mechanism considers two kinds of variables
(\pxref{Variables}), logical variables and program variables. Keep in mind that
logical variables are bound once onward and stay bound on a successful
execution (this is similar to PROLOG variable). However program variables,
which are provided for convenience, can be rebound at any time.

Last, but not least, it is in the unification (but not only in the unification)
that evaluable functions (\pxref{Evaluable Functions}), are evaluated.  This
means that a term containing an evaluable function is evaluated whenever one
attempts to unify it. It used to be that the evaluation of terms appearing in a
goal were delayed until unification was required.  Recent versions of the kernel
still allow this mechanism, but it is not the default anymore. Now to prevent
the evaluation of terms at posting time, you need to surround the term in a
\code{quote} form (\pxref{Current and Quote}).

Nevertheless, if a term containing an evaluable function is in the scope of a
\code{quote}, this can lead to a very peculiar behavior particularly if this
evaluable function runs with considerable overhead, or if it has side effects
(such as printing). You may get the feeling that your function is evaluated
more than it should be. To avoid this mechanism, you can use the \code{current}
mechanism in the scope of the quote.

\section{Conclude}
\node{Conclude}
\cpindex{Conclude}

The conclude operation is the operation by which you add something to the
database. Only expressions, without variables, are allowed. All the evaluable
functions found in the expression are evaluated and the result is concluded,
not the original expression. For example, if you conclude \code{(foo (+ 1 2) (-
5 4))}, then \code{(foo 3 1)} ends up in the database.

You can conclude facts with negation, \code{(\~{} (foo 3 1))}, for example.
Moreover, when an expression is concluded, its negation, if found, is
automatically retracted from the database.

Of course, concluding the negation of closed world predicates is a
\i{no-op} (\pxref{Closed World Predicates}). Similarly, concluding an
evaluable predicate produces a warning. For example, if you conclude
\code{(> 3 1)}, the system reports a non fatal error, even if the
expression is true.

\section{Consultation}
\node{Consultation}
\cpindex{Consultation}

One can consult general expression (\pxref{General Expressions}), with
variables. Conjunctions and disjunctions are treated, as expected, with the
variables having scope over the whole general expression. In \code{(\& (foo \$x
6) (bar \$x 7))}, the \code{\$x} variable is the same in both expressions.  If
you do not want this behavior, you should use two different variables.  When a
disjunction is consulted, all the possible sub general expressions which are
satisfied are returned. If you have \code{(foo 1 6)} and \code{(bar 1 7)} in
the database, and consult \code{(|| (foo 1 6) (bar 1 7))}, you get three
possible solutions: \code{(|| (foo 1 6) (bar 1 7))}, \code{(|| (bar 1 7))} and
\code{(|| (foo 1 6))}. One can easily imagine that consulting a big disjunction
with lot of simple true expressions leads to a huge number of solutions. For
example, N disjunctions, each being true for M values, would lead to (M**N)!/N!
solutions! No need to say that extreme caution should be exerted when writing
disjunction in OPs.

When you consult a general expression in the database, the kernel returns a
list of facts. If the appropriate flag is on (\code{trace db frame on|off})
(\pxref{OPRS Kernel Trace Commands}), it will return each fact with the frames
which, when applied to the consulted fact, make each returned fact be true.
Note that for internal consultation, facts themselves are of little if no
interest for the kernel. Only the frame is important. The deepest frame in the
hierarchy is the frame in which the fact you consult has been created (most
likely an empty frame with the variables present in the consulted gexpression).

If you have \code{(foo 1 6)} and \code{(foo 2 6)} in your database, and
you consult \code{(foo \$x 6)}, then it returns something like:
\begin{verbatim}
FOO> conclude (foo 1 6)
The expression:( FOO 1 6 )  has been concluded in the database.

FOO> conclude (foo 2 6)
The expression:( FOO 2 6 )  has been concluded in the database.

FOO> consult (foo $x 6)
The user consultation of: ( FOO {$X->(Term *)NULL } 6 ) 
gives the following result:
( FOO 2 6 ) 
( FOO 1 6 ) 

FOO> trace db frame on

FOO> consult (foo $x 6)
The user consultation of: ( FOO {$X->(Term *)NULL } 6 )
gives the following result:
[ ( FOO 2 6 ) { 0 ([{$X->(Term *)NULL}>>2 ] )
               { ({$X->(Term *)NULL} ) 1 () {} } } ]
[ ( FOO 1 6 ) { 0 ([{$X->(Term *)NULL}>>1 ] )
               { ({$X->(Term *)NULL} ) 1 () {} } } ]
\end{verbatim}

Note that the format of the returned information is a list of:
\begin{verbatim}
fact
\end{verbatim}
or
\begin{verbatim}
[ fact frame-in-which-the-fact-is-true ]
\end{verbatim}
depending of the \code{db\_frame} flag (\pxref{OPRS Kernel Trace Commands}).

Multiple frames are returned when the consultation returns more than one
possible value. Moreover, if the consultation leads to a tree search
because of a conjunction or a disjunction in the consulted gexpression,
then you get more than one level of nested frames.

\begin{verbatim}
FOO> conclude (foo a b)
The expression:( FOO A B )  has been concluded in the database.

FOO> conclude (bar b c)
The expression:( BAR B C )  has been concluded in the database.

FOO> conclude (bar b d)
The expression:( BAR B D )  has been concluded in the database.

FOO> consult (& (foo $x $y) (bar $y $z))
The user consultation of:
( & ( FOO {$X->(Term *)NULL } {$Y->(Term *)NULL } )
    ( BAR {$Y->(Term *)NULL } {$Z->(Term *)NULL } ) )
gives the following result:
[ ( & ( FOO A B ) ( BAR B C ) )
  { 0 ([{$Z->(Term *)NULL } >>C ] )
   { 0 ([{$Y->(Term *)NULL } >>B ] [{$X->(Term *)NULL } >>A ] )
    { 1 ()
     {} } } } ]
[ ( & ( FOO A B ) ( BAR B D ) )
  { 0 ([{$Z->(Term *)NULL } >>D ] )
   { 0 ([{$Y->(Term *)NULL } >>B ] [{$X->(Term *)NULL } >>A ] )
    { 1 ()
     {} } } } ]

FOO> consult (|| (foo $x $y) (bar $y $z))
The user consultation of:
( || ( FOO {$X->(Term *)NULL } {$Y->(Term *)NULL } )
    ( BAR {$Y->(Term *)NULL } {$Z->(Term *)NULL } ) )
gives the following result:
[ ( || ( BAR B C ) )
  { 0 ([{$Z->(Term *)NULL } >>C ] [{$Y->(Term *)NULL } >>B ] )
   { 1 ()
    {} } } ]
[ ( || ( BAR B D ) )
  { 0 ([{$Z->(Term *)NULL } >>D ] [{$Y->(Term *)NULL } >>B ] )
   { 1 ()
    {} } } ]
[ ( || ( FOO A B ) )
  { 0 ([{$Y->(Term *)NULL } >>B ] [{$X->(Term *)NULL } >>A ] )
   { 1 ()
    {} } } ]
[ ( || ( FOO A B ) ( BAR B C ) )
  { 0 ([{$Z->(Term *)NULL } >>C ] )
   { 1 ()
    {} } } ]
[ ( || ( FOO A B ) ( BAR B D ) )
  { 0 ([{$Z->(Term *)NULL } >>D ] )
   { 1 ()
    {} } } ]
\end{verbatim}

\section{Closed World Predicates}
\node{Closed World Predicates}
\cpindex{Closed World Predicates}

A closed world predicate, in short CWP, is a mechanism by which one can
specify what to do in the absence of information about some predicate. In
\CPK{} database, facts are known to be true if they are in the database
and are considered false if they are absent. As a consequence, in the absence
of any information about an expression and its negation. Both are considered to
be false. However, in many situations, the absence of some information is
considered as if it were false. For example, assume you have built a database
containing information about flights between cities. If your database does not
contain the fact that there is a direct flight between Toulouse and San
Francisco, most likely, it means that no such flight exists. Therefore, if you
ask \code{consult (direct-flight TLS SFO)}, it returns FALSE. But if you ask
\code{consult (\~{} (direct-flight TLS SFO))}, then it also returns FALSE by
default, although it is TRUE. In fact, one solution would be to enter all the
possible flights which do not exist, by adding explicitly \code{(\~{}
(direct-flight TLS SFO))} and all the other ones.  This is tedious and will
clutter your database with unnecessary information.

The solution to this problem in \CPK{} is to declare the predicate
\code{direct-flight} as CWP with the following command: \code{declare\_cwp
direct-flight} (\pxref{OPRS Kernel Database Commands}). It means
automatically that any consultation of the negation of this predicate
(such as \code{consult (\~{} (direct-flight TLS SFO))}) returns TRUE if the
positive (\code{(direct-flight TLS SFO)}) is not in the database.

When you declare evaluable predicate (\pxref{Evaluable Predicates}), you
can also specify if they are CWP or not. All the evaluable predicates
predefined in the kernel are CWP.

A side effect of this declaration is that any attempt to conclude the
negation of a CWP is ignored by the database. Indeed, what would be
the point of concluding \code{(\~{} (direct-flight TLS SFO))} as it is true
anyway (providing of course that \code{(direct-flight
TLS SFO)} is not in the database).

Here are some examples to illustrate the CWP mechanism:
\begin{verbatim}
FOO> consult (foo a)
The user consultation of: ( FOO A ) gives the following result:
NULL

FOO> consult (~ (foo a))
The user consultation of: ( ~ (FOO A ) ) gives the following result:
NULL

FOO> declare cwp foo

FOO>  consult (foo a)
The user consultation of: ( FOO A ) gives the following result:
NULL

FOO> consult (~ (foo a))
The user consultation of: ( ~ (FOO A ) ) gives the following result:
[ ( ~ (FOO A ) ) { 1 () {} } ]

FOO> consult (~ (foo $x))
The user consultation of:
( ~ (FOO {$X->(Term *)NULL } ) )
gives the following result:
[ ( ~ (FOO {$X->(Term *)NULL } ) ) { 1 () {} } ]

FOO> conclude (foo a)
The expression:( FOO A )  has been concluded in the database.

FOO> consult (foo a)
The user consultation of:
( FOO A )
gives the following result:
[ ( FOO A ) { 0 () { 1 () {} } } ]

FOO> consult (foo $x)
The user consultation of:
( FOO {$X->(Term *)NULL } )
gives the following result:
[ ( FOO A )
  { 0 ([{$X->(Term *)NULL } >>A ] ){ 1 () {} } } ]

FOO> consult (~ (foo a))
The user consultation of:
( ~ (FOO A ) )
gives the following result:
NULL

FOO>  consult (~ (foo $x))
The user consultation of:
( ~ (FOO {$X->(Term *)NULL } ) )
gives the following result:
NULL

FOO> conclude (~ (foo a))
The expression:( ~ (FOO A ) )  has been concluded in the database.

FOO> consult (foo a)
The user consultation of: ( FOO A ) gives the following result:
NULL

FOO> consult (foo $x)
The user consultation of: ( FOO {$X->(Term *)NULL } )
gives the following result:
NULL

FOO> consult (~ (foo a))
The user consultation of: ( ~ (FOO A ) )
gives the following result:
[ ( ~ (FOO A ) ) { 1 () {} } ]

FOO>  consult (~ (foo $x))
The user consultation of: ( ~ (FOO {$X->(Term *)NULL } ) )
gives the following result:
[ ( ~ (FOO {$X->(Term *)NULL } ) ) { 1 () {} } ]
\end{verbatim}

Note the absence of binding on the consultation of CWP expression with
variables.

\section{Functional Facts}
\node{Functional Facts}
\cpindex{Functional Facts}

Functional facts are predicates which can be expressed as a function of a
subset of their arguments which gives the rest of their arguments as a result.
In some cases, there is only one possible result: \\* For example:
\code{(factorial 5 120)} (because \code{factorial(5) => 120}).  This result
being unique (\code{factorial 5} is always \code{120}), there is no reason a
priori to make any bookkeeping on it. But in some situations or applications,
the result is not unique and can change over time.  For example: \\*
\code{(pressure tk1 245)} (indeed, we can express the fact that
\code{pressure(tk1) => 245}). \\* Most likely, there is only one possible value
of pressure at one time, therefore any previously recorded value for \code{tk1}
should be discarded. In this case, if we had received \code{(pressure tk1 250)}
few minutes (or seconds) ago, we must remove it from the database, otherwise
the consultation of \code{(pressure tk1 \$x)} would return both facts, which is
wrong.

You can certainly write your own procedure to clean up automatically.
However, the \CPK{} provides an automatic mechanism to handle this type of
cleanup. It is called functional fact, and you can declare any predicate
as a functional fact with the following command: \code{declare ff
predicate position} (\pxref{OPRS Kernel Declaration Commands}).
\code{predicate} is the name of the predicate. \code{position} is the
argument position at which the argument becomes the result of the
functional evaluation. For example, in the pressure example above, you
would invoke: \code{declare ff pressure 1}.

For a predicate like: \\*
\code{(position-robot building-E)},\\*
it is \\*
\code{declare ff position-robot 0},\\*
because \\*
\code{position-robot() =>building-E}. \\*
For a predicate like \\*
\code{(connection-status paris toulouse up)},\\*
it is \\*
\code{declare ff connection-status 2},\\*
because \\*
\code{connection-status(paris, toulouse) => up}.

This mechanism requires the order of the arguments to be organized in such
a way that the value arguments of the functional evaluation come after
the arguments required for the evaluation. If you said
\code{(pressure 250 tk1)}, then you cannot use this mechanism (or we would
have to use position pattern to declare the functional facts).

Note that in this section, we mention that the predicate is considered as
functional, which does not mean it is evaluable (\pxref{Evaluable Predicates}), but merely that it could be expressed as functional.

All functional fact predicates are also considered as closed world predicate
(\pxref{Closed World Predicates}).

Many users have asked us to extend this mechanism to an \dfn{history}
mechanism. You could then declare that you want to keep the last five
values of a functional fact. This notion of history is heavily linked to
the notion of \dfn{time stamping} the information stored in the database.
As usual, there are pros and cons of such a mechanism. However, we are
currently considering adding it. As of now, you need to do the bookkeeping
yourself when you need more previous values, to do trend analysis for
example.

Here are some examples to illustrate the functional fact mechanism:

\begin{verbatim}
FOO> consult (foo $x)
The user consultation of: ( FOO {$X->(Term *)NULL } )
gives the following result:
NULL

FOO> conclude (foo a)
The expression:( FOO A )  has been concluded in the database.

FOO> consult (foo $x)
The user consultation of: ( FOO {$X->(Term *)NULL } )
gives the following result:
[ ( FOO A ) { 0 ([{$X->(Term *)NULL } >>A ] )
             { 1 () {} } } ]

FOO> conclude (foo b)
The expression:( FOO B )  has been concluded in the database.

FOO> consult (foo $x)
The user consultation of: ( FOO {$X->(Term *)NULL } )
gives the following result:
[ ( FOO A ) { 0 ([{$X->(Term *)NULL } >>A ] )
             { 1 () {} } } ]
[ ( FOO B ) { 0 ([{$X->(Term *)NULL } >>B ] )
             { 1 () {} } } ]

FOO> declare ff foo 0

FOO> conclude (foo c)
The expression:( FOO C )  has been concluded in the database.

FOO> consult (foo $x)
The user consultation of: ( FOO {$X->(Term *)NULL } )
gives the following result:
[ ( FOO C ) { 0 ([{$X->(Term *)NULL } >>C ] )
             { 1 () {} } } ]

FOO> conclude (foo d)
The expression:( FOO D )  has been concluded in the database.

FOO> consult (foo $x)
The user consultation of: ( FOO {$X->(Term *)NULL } )
gives the following result:
[ ( FOO D ) { 0 ([{$X->(Term *)NULL } >>D ] )
             { 1 () {} } } ]
\end{verbatim}

\section{Basic Events}
\node{Basic Events}
\cpindex{Basic Events}

Basic events are used to handle facts which are ``transients'', i.e.\ facts
which must be noticed by the \CPK{} but should not be kept in the
database. Keep in mind that any fact or message which is received by a
\CPK{} is stored in the database by default.

For example, you may want your application to notice facts such as
\code{(alarm)}, but do not want it to remember this fact. You can declare
the \code{alarm} predicate as a basic event. To do so, you need to issue
the \code{declare be alarm} (\pxref{OPRS Kernel Declaration Commands}),
command in this kernel (or put it in the include file which will be loaded
in this kernel). Similarly, you may want your application to monitor some
pressure values but do not want to keep these values (even the last one).
You could then issue the command \code{declare be pressure} (assuming that
the pressure predicate is used to carry this information).

Note that you can declare any predicate as a basic event, and some
predefined predicates are actually basic event predicates.
Here is the list of the predicates which are, by default, declared as
basic events in the kernel. \\*
\code{SOAK}, \\*
\code{APPLICABLE-OPS-FACT}, \\*
\code{FACT-INVOKED-OPS}, \\*
\code{DB-SATISFIED-GOAL}, \\*
\code{APPLICABLE-OPS-GOAL}, \\*
\code{GOAL-INVOKED-OPS},
\code{FAILED-GOAL}, \\*
\code{FAILED}, \\*
\code{REQUEST}, \\*
\code{ACHIEVED}, \\*
\code{INTENTION-WAKE-UP}, \\*
\code{READ-RESPONSE-ID}, \\*
\code{READ-RESPONSE}.

You can undeclare a basic event with the command: \code{undeclare\_be}
(assuming it was declared as a basic event).

\section{Evaluable Predicates}
\node{Evaluable Predicates}
\cpindex{Evaluable Predicates}

\COPRS{} provides mechanisms to define, incorporate and use evaluable
predicates. By default there are a number of predefined
evaluable predicates. However, the user can add its own
definition of evaluable predicates, and even redefine the
one which are defined by default in the kernel.

Evaluable predicates are used whenever you want to have a predicate to
correspond to some C code (or code linked in the \CPK{}), which
evaluation describes the extension of the predicate.

Evaluable predicates are evaluated at the database level (which explain
why we present them in this Chapter). In fact, from the final user point of
view, the mechanism is completely transparent, they look like standard predicates. The
database somehow ``recognizes'' them as being evaluable, evaluates
their arguments and the predicates themselves instead of looking in the
expression table . Evaluable predicates can be consulted as well as other
predicates.

However, consulting \code{(> (+ 3 4) (- 3 4))} in the database (with a
the \code{consult} command), evaluates \code{(+ 3 4)} and \code{(- 3
4)} which respectively returns \code{7} and \code{-1} (\pxref{Evaluable Functions}, for more on this subject). Then, it
evaluates the \code{(> 7 -1)} and it returns TRUE.

One can see from this mechanism that it is not possible to use an evaluable
predicate in an environment where the terms are undefined (or unbound). It is
usually meaningless, and very often an error, to consult evaluable predicates
with unbound variables. Such as:\\* \code{(> 4 \$x)} when \code{\$x} is unbound.
In fact the \code{>} predicate will print an error message.

Evaluable predicates can be used whenever a predicate is appropriate,
however, you cannot use evaluable predicates in an Invocation Part. If you
use a predicate in an Invocation Part, it will not be able to trigger the
relevance of this OP as any predicate of the Invocation Part should.


\subsection{Predefined Evaluable Predicates}
\node{Predefined Evaluable Predicates}
\cpindex{Predefined Evaluable Predicates}

All the evaluable predicates return a \code{PBoolean}, i.e.\ \code{TRUE} or
\code{FALSE} (\pxref{Important Constants}), not a Term. Besides, all the
evaluable predicates take a \code{TermList} as an argument. Whenever it is
possible, we will specify the number of arguments and the type of the
\code{Term} for each element.

To help the reader understand the descriptions for the evaluable predicates
in the following section, consider the \code{>} (greater than) evaluable predicate:

\begin{typeep}{Evaluable Predicate} {PBoolean} {>} {(LONG\_LONG or INTEGER or FLOAT)}
is the greater than function. It is defined for two terms (subsequent
terms in the list are ignored). It can compare any numbers (\code{INTEGER} or
\code{FLOAT}).
\end{typeep}

The \code{PBoolean} before the predicate name \code{>} is the type returned
by the evaluable predicate.  The \code{(INTEGER or FLOAT INTEGER or FLOAT)}
after the predicate name specifies the type of the object contained in the
TermList which is the argument to the \code{>} predicate. In this case, it
means at least two arguments which must be \code{FLOAT} or \code{INTEGER}
\code{Term *}.  \xref{liblist.a library}, for examples of how to access
different types of objects contained in TermList, as well as \nxref{How to Define your Own Evaluable Predicates}.

Evaluable predicates can be classified in different categories which are
presented in the following section.



\subsubsection{Arithmetic Evaluable Predicates}
\node{Arithmetic Evaluable Predicates}
\cpindex{Arithmetic Evaluable Predicates}

These predicates deal with numbers.

\begin{typeep}{Evaluable Predicate} {PBoolean} {>} {(INTEGER or FLOAT INTEGER or FLOAT)}
is the greater than function. It is defined for two terms (subsequent
terms in the list are ignored). It can compare any numbers (\code{INTEGER} or
\code{FLOAT}).
\end{typeep}

\begin{typeep}{Evaluable Predicate}{PBoolean}{>=}{(INTEGER or FLOAT INTEGER or FLOAT)}
is the greater than or equal function. It is defined for two terms
(subsequent terms in the list are ignored). It can compare any numbers
(\code{INTEGER} or \code{FLOAT}).
\end{typeep}

\begin{typeep}{Evaluable Predicate} {PBoolean} {<} {(INTEGER or FLOAT INTEGER or FLOAT)}
is the less than function. It is defined for two terms (subsequent terms
in the list are ignored). It can compare any numbers (\code{INTEGER} or \code{FLOAT}).
\end{typeep}

\begin{typeep}{Evaluable Predicate} {PBoolean} {<=} {(INTEGER or FLOAT INTEGER or FLOAT)}
is the less than or equal function. It is defined for two terms
(subsequent terms in the list are ignored). It can compare any numbers
(\code{INTEGER} or \code{FLOAT}).
\end{typeep}

\subsubsection{OP Instance Related Evaluable Predicates}
\node{OP Instance Related Evaluable Predicates}
\cpindex{OP Instance Related Evaluable Predicates}

These predicates deal with OP Instance and the properties of the OP they are an
instance of.

\begin{typeep}{Evaluable Predicate}{PBoolean}{PROPERTY-P}{(ATOM property,TT\_OP\_INSTANCE)}
is the function used to check if a property is defined.  It is defined for
two terms, a term symbol, the property name, and a \code{TT\_OP\_INSTANCE}
(subsequent terms in the list are ignored). It returns \code{TRUE} if the
specified property is non-nil for the specified OP Instance. Note that
this does not return the value of the property, but merely if it is
defined and non-nil. If you want to access the value of the property, use
the evaluable function: \code{property-of}.
\end{typeep}

\begin{typeep}{Evaluable Predicate}{PBoolean} {NOT-AN-INSTANCE-OF-ME} {(TT\_OP\_INSTANCE)}
is defined for 1 term a \code{TT\_OP\_INSTANCE}. It returns \code{TRUE} if
the OP, in which this predicate appears in the invocation, or context part, is
not the OP from which the op-instance parameter is an instance. This is very
useful for Meta level OPs to prevent them of looping on themselves...
\end{typeep}

\begin{typeep}{Evaluable Predicate}{PBoolean} {IS-FACT-INVOKED} {(TT\_OP\_INSTANCE)}
is defined for 1 term a \code{TT\_OP\_INSTANCE}. It returns \code{TRUE} if
the op-instance parameter is invoked by a fact.
\end{typeep}

\begin{typeep}{Evaluable Predicate}{PBoolean} {IS-GOAL-INVOKED} {(TT\_OP\_INSTANCE)}
is defined for 1 term a \code{TT\_OP\_INSTANCE}. It returns \code{TRUE} if
the op-instance parameter is invoked by a goal.
\end{typeep}

\subsubsection{Time Related Evaluable Predicates}
\node{Time Related Evaluable Predicates}
\cpindex{Time Related Evaluable Predicates}

These predicates deal with time and elapsed time.

\begin{typeep}{Evaluable Predicate}{PBoolean}{ELAPSED-TIME}{(INTEGER t1, INTEGER t2)}
is the predicate used to check if the number of seconds t2 have elapsed since
t1. It is mainly used in a construct such as \code{(\^{} (elapsed-time (time) 5))}.
\end{typeep}

\begin{typeep}{Evaluable Predicate}{PBoolean}{ELAPSED-MTIME}{(INTEGER t1, INTEGER t2)}
is the predicate used to check if the number of milliseconds t2 have elapsed
since t1.  It is mostly used in a construct such as \code{(\^{} (elapsed-mtime
(mtime) 5))}. Keep in mind that if the \CPK{} has nothing to do, except
checking this predicate, then it will wake up every \code{main\_loop\_pool\_sec *
1000000 + main\_loop\_pool\_usec} micro seconds (this value can be reduced if
needed) (\pxref{Important Variables}).

\strong{Due to possible overlapping reasons, do not use this predicate
with big values of t2. For values greater than 10 000 or so, use
\code{elapsed-time} and \code{time} instead which count seconds}.
\end{typeep}

\subsubsection{Miscellaneous Evaluable Predicates}
\node{Miscellaneous Evaluable Predicates}
\cpindex{Miscellaneous Evaluable Predicates}

These miscellaneous predicates deal with various objects and types.

\begin{typeep}{Evaluable Predicate}{PBoolean}{=}{(AnyTerm AnyTerm)}
is the assignment predicate. This predicate used to be satisfied by a OP, it is
now defined as an evaluable predicate. (Note: that you can still define it as a
OP). It is defined for two terms. It returns \code{TRUE} if it manage to assign
(or unify) the value of the second term to the first term. Most of the time,
the first term is a variable.
\end{typeep}

\begin{typeep}{Evaluable Predicate}{PBoolean}{==}{(AnyTerm AnyTerm)}
is the unification predicate.  This predicate used to be satisfied by a OP, it
is now defined as an evaluable predicate. (Note: that you can still define it
as a OP). It is defined for two terms. It returns \code{TRUE} if it managed to
unify the second term with the first term. One advantage of having this
predicate defined as an evaluable predicate is that you can use it in complex
statement such as: \code{(? (|| (== \$x (foo a b)) (== (foo a b) (foo \$x \$y))))}
\end{typeep}

\begin{typeep}{Evaluable Predicate}{PBoolean}{NULL}{(LISP\_LIST)}
is the Lisp List NULL function. It is defined for one term (subsequent terms in
the list are ignored). It returns \code{TRUE} if the Lisp List is empty.
\end{typeep}

\begin{typeep}{Evaluable Predicate}{PBoolean}{NULL\_CAR}{(Any Term)}
is the Lisp List NULL function. It is defined for one term. It returns
\code{TRUE} if the \code{Term} is NULL, as extracted with a \code{CAR} from an
empty Lisp list.
\end{typeep}

\begin{typeep}{Evaluable Predicate}{PBoolean}{MEMQ}{(Any Term, LISP\_LIST)}
returns
\code{TRUE} if the \code{Any Term} is in the\ code{LISP\_LIST}.
\end{typeep}

\begin{typeep}{Evaluable Predicate}{PBoolean}{NULL\_C}{(OPRS\_LIST)}
is the C\_List NULL function. It is defined for one term (subsequent terms in
the list are ignored). It returns \code{TRUE} if the \code{OPRS\_LIST} is empty. 
\end{typeep}

\begin{typeep}{Evaluable Predicate}{PBoolean}{EQUAL}{(TermList \var{terms})}
is the equal terms function. It is defined for two terms (subsequent terms
in the list are ignored). It returns \code{TRUE} if both terms are equal.
\end{typeep}

\begin{typeep}{Evaluable Predicate}{PBoolean}{BOUNDP}{(Any Term)}
It is defined for one term (subsequent terms in the list are ignored). It
returns \code{FALSE} if the term is a \code{VARIABLE} and it is not bound.
Return \code{TRUE} in all other cases.
\end{typeep}

\begin{typeep}{Evaluable Predicate}{PBoolean}{NUMBERP}{(Any Term)}
It is defined for one term (subsequent terms in the list are ignored). It
returns \code{TRUE} if the term is a \code{FLOAT}, an \code{INTEGER} or a \code{LONG\_LONG}, and 
returns \code{FALSE} otherwise.
\end{typeep}

\begin{typeep}{Evaluable Predicate}{PBoolean}{INTEGERP}{(Any Term)}
It is defined for one term (subsequent terms in the list are ignored). It
returns \code{TRUE} if the term is an \code{INTEGER}, and 
returns \code{FALSE} otherwise.
\end{typeep}

\begin{typeep}{Evaluable Predicate}{PBoolean}{FLOATP}{(Any Term)}
It is defined for one term (subsequent terms in the list are ignored). It
returns \code{TRUE} if the term is a \code{FLOAT}  and 
returns \code{FALSE} otherwise.
\end{typeep}

\begin{typeep}{Evaluable Predicate}{PBoolean}{LONG-LONGP}{(Any Term)}
It is defined for one term (subsequent terms in the list are ignored). It
returns \code{TRUE} if the term is a \code{LONG\_LONG}, and 
returns \code{FALSE} otherwise.
\end{typeep}

\begin{typeep}{Evaluable Predicate}{PBoolean}{STRINGP}{(Any Term)}
It is defined for one term (subsequent terms in the list are ignored). It
returns \code{TRUE} if the term is a \code{STRING}, and 
returns \code{FALSE} otherwise.
\end{typeep}

\begin{typeep}{Evaluable Predicate}{PBoolean}{CONSP}{(Any Term)}
It is defined for one term (subsequent terms in the list are ignored). It
returns \code{TRUE} if the term is a \code{LISP\_LIST}, and 
returns \code{FALSE} otherwise.
\end{typeep}

\begin{typeep}{Evaluable Predicate}{PBoolean}{ATOMP}{(Any Term)}
It is defined for one term (subsequent terms in the list are ignored). It
returns \code{TRUE} if the term is a \code{ATOM}, and 
returns \code{FALSE} otherwise.
\end{typeep}

\subsection{How to Define your Own Evaluable Predicates}
\node{How to Define your Own Evaluable Predicates}
\cpindex{How to Define your Own Evaluable Predicates}

It is fairly easy to define your own evaluable predicates. To do so, you
have to write a C function which takes a list of terms (TermList) as
arguments and returns a PBoolean (\code{TRUE} or \code{FALSE}). Using the list library
functions, you can then access the element of the list and compute the
Boolean value.

You will find various examples of user-defined evaluable predicates in the
file: \file{user-ev-predicate.c}.

\begin{verbatim}
PBoolean my_predicate(TermList tl)
{
     Term *t1, *t2;

     t1 = (Term *)get_list_pos(tl, 1);
     t2 = (Term *)get_list_pos(tl, 2);

     if (my_fancy_condition(t1, t2)) return TRUE;
     else return FALSE;
}
\end{verbatim}

You can define as many evaluable predicates as you want. You need to
declare them in the kernel, as well as their external names (as it will
appear in the OPs), the number of arguments they take and whether they are
closed world predicates or not. This declaration is made in the body of
the \code{declare\_user\_eval\_pred} function which is called upon start up
of the kernel.

\begin{verbatim}
void declare_user_eval_pred(void)
{
     make_and_declare_eval_pred("EXTERNAL_NAME", my_predicate, 2, TRUE);
     return;
}
\end{verbatim}

\begin{typefn}{Kernel User Function}{void}{make\_and\_declare\_eval\_pred}
        {(Predicat \var{name}, PFB \var{pred}, int \var{ar}, PBoolean \var{cwp})}
is used to declare the evaluable predicate. You have to specify the
predicate name, the C function which implements it, the arity of this
predicate and a boolean to indicate if the predicate is a closed world
predicate.
\end{typefn}

\begin{typefn}{Kernel User Function}{void}{declare\_user\_eval\_pred}{(void)} 
is the function in which you must put all the calls to
\code{make\_and\_declare\_eval\_pred}. It is called upon start-up by the kernel and
builds the appropriate table to map the evaluable predicate names and the
corresponding C functions. Note that the user can redefine the predefined
evaluable predicates by using their names. This can be useful for example if
you want to overload their definitions.
\end{typefn}

\section{OP Predicates}
\node{OP Predicates}
\cpindex{OP Predicates}

OP predicates cannot be satisfied in the database, they
can only be satisfied by OP execution. Keep in mind that whenever the system
posts a goal, it will check if this goal is already satisfied in the database.
There exists a number of predicates that can only be satisfied by OP execution
(example \code{print}, \code{send-message},
\code{execute-command}, \code{read-inside}, etc.), for them, there is no need to
check if they are satisfied or not in the database, so they should be declared
as OP predicate. 

As a consequence, consulting expressions in which the predicate is a OP predicate in
the database result as a non operation.  Similarly, if you attempt to conclude
a OP predicate in the database, the system will print a warning.

\chapter{Evaluable Functions}
\node{Evaluable Functions}
\cpindex{Evaluable Functions}

\COPRS{} provides mechanisms to define, incorporate and use evaluable
functions. By default there are a number of predefined evaluable functions.
However, you can add a definition of evaluable functions, and even
redefine the ones which are defined by default in the kernel. Actions (which
have similitude with evaluable functions) are presented in \nxref{Using Action OPs}.

Evaluable functions are used whenever you want to evaluate some expressions, to
compute some results, or to have some ``side effects'' on external modules (by
sending a message, or by calling a function which will have some effects on
these external modules).

Evaluable functions can be used in a Composed Term embedded in an Expression.
Whenever an evaluable function is called, each argument must be defined and
bound (unless the function is able to handle gracefully unbound variable, but this is
unlikely).



\section{Predefined Evaluable Functions}
\node{Predefined Evaluable Functions}
\cpindex{Predefined Evaluable Functions}

All the evaluable functions return a \code{Term *}, i.e.\ a pointer to a
\code{Term} structure (\pxref{Data Structures and Types Used}). However, this
term can contain different types of objects (\pxref{Terms}), and this is left
to the user to decide which type he needs to return. In the following
description, we will indicate which is the type of the object contained in the
\code{Term *} returned by the evaluable function. Besides, all the evaluable
functions take a \code{TermList} as an argument. Whenever it is possible, we
will specify the number of arguments and the type of the \code{Term} for each
element.

To help the reader understand the descriptions for the evaluable functions
in the following section, consider the \code{+} (plus) evaluable function:

\begin{typeefa}{Evaluable Function}{INTEGER or FLOAT or
    LONG\_LONG}{+}{({INTEGER or LONG\_LONG or FLOAT}+)} is the plus function.
  It is defined for n terms. It adds any numbers to the first argument
  (\code{INTEGER} or \code{LONG\_LONG} or \code{FLOAT}), and returns a term
  containing the result casted according to the passed arguments (if all
  \code{INTEGER}s then \code{INTEGER}, if all \code{INTEGER} or
  \code{LONG\_LONG} then \code{LONG\_LONG}, \code{FLOAT} otherwise).
\end{typeefa}

The \code{INTEGER or LONG\_LONG or FLOAT} before the function name \code{+}
is the type of the object contained in the \code{Term *} object that is
returned by this \code{+} function.  The \code{(INTEGER or LONG\_LONG or
  FLOAT)+} after the function name specifies the type of the object
contained in the TermList which is the argument to the \code{plus} function.
In this case, it means at least one argument (this is represented with the
trailing +), and all the arguments must be \code{FLOAT}, \code{LONG\_LONG} or
\code{INTEGER} \code{Term *}.  \xref{liblist.a library}, for examples of how
to access different types of objects contained in TermList, as well as
\nxref{How to Define your Own Evaluable Functions}, for examples of how to
store different types of objects in a \code{Term *} that will be returned by
evaluable functions.

Evaluable functions can be classified in different sections according to their
type, or to the type of objects they manipulate/return.



\subsection{Arithmetic Evaluable Functions}
\node{Arithmetic Evaluable Functions}
\cpindex{Arithmetic Evaluable Functions}

These evaluable functions deal with numbers and perform the common arithmetic
operation. All functions taking \code{INTEGER} or \code{FLOAT} also now
takes \code{LONG\_LONG}... and behave as expected with respect to casting.

\begin{typeefa}{Evaluable Function}{INTEGER or FLOAT}{+}{({INTEGER or FLOAT}+)}
is the plus function. It is defined for n terms. It adds any numbers to the
first argument (\code{INTEGER} or \code{FLOAT}), and returns a term containing
the result casted according to the passed arguments (if all \code{INTEGER}s
then \code{INTEGER}, \code{FLOAT} otherwise).
\end{typeefa}

\begin{typeefa}{Evaluable Function}{INTEGER or FLOAT}{-}{({INTEGER or FLOAT}+)}
is the difference function. It is defined for n terms. It subtracts any
number to the first argument (\code{INTEGER} or \code{FLOAT}), and returns a term containing
the result casted according to the passed arguments (if all \code{INTEGER}s then \code{INTEGER},
\code{FLOAT} otherwise). With one argument, it returns the minus.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{INTEGER or FLOAT}{*}{({INTEGER or FLOAT}+)}
is the time function. It is defined for n terms. It multiplies any numbers
(\code{INTEGER} or \code{FLOAT}), and returns a term containing the result casted according
to the passed arguments (if all \code{INTEGER}s then \code{INTEGER}, \code{FLOAT} otherwise).
\end{typeefa}

\begin{typeefa}{Evaluable Function}{INTEGER or FLOAT}{/}{({INTEGER or FLOAT}+)}
is the divide function. It is defined for n terms. It divides the first
number (\code{INTEGER} or \code{FLOAT}) by the subsequent numbers, and returns a term
containing the result casted according to the passed arguments (if all \code{INTEGER}
then \code{INTEGER}, \code{FLOAT} otherwise). With one argument, it returns the inverse.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{INTEGER or FLOAT}{abs}{({INTEGER or FLOAT})}
is the abs function. It is defined for 1 term. It returns the abs value of
its argument (\code{INTEGER} or \code{FLOAT}).
\end{typeefa}

\begin{typeefa}{Evaluable Function}{INTEGER}{mod}{(INTEGER INTEGER)}
is the modulo function. It is defined for two \code{INTEGER} terms. It returns an
\code{INTEGER}, the modulo of the two integers (it is equivalent to the C
\code{\%} operation).
\end{typeefa}

\begin{typeefa}{Evaluable Function}{INTEGER}{rand}{(INTEGER)}
 is defined for one \code{INTEGER} terms. It returns a random
\code{INTEGER} between 0 and the int given as argument (not included).
\end{typeefa}

\begin{typeefa}{Evaluable Function}{INTEGER}{float-to-int}{({FLOAT})}
is defined for 1 term. It returns the \code{FLOAT} or \code{INTEGER } passed as argument casted in
an \code{INTEGER}. 
\end{typeefa}

\begin{typeefa}{Evaluable Function}{FLOAT}{int-to-float}{({INTEGER})}
is defined for 1 term. It returns the \code{INTEGER} ,\code{LONG\_LONG}  or \code{FLOAT} passed as argument casted
in a \code{FLOAT}.
\end{typeefa}

\subsection{Array Manipulation Evaluable Functions}
\node{Array Manipulation Evaluable Functions}
\cpindex{Array Manipulation Evaluable Functions}

These evaluable functions deal with array, \code{INT\_ARRAY} and
\code{FLOAT\_ARRAY}. \xref{Array of Floats as a Term} and \nxref{Array of Integers as a Term}, for more information on arrays.

\begin{typeefa}{Evaluable Function}{FLOAT\_ARRAY}{make-float-array}{(INTEGER \var{size})}
returns a \code{Term *} containing a \code{FLOAT\_ARRAY} of size \var{size}.
This function should be used in a Special Action.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{FLOAT}{get-float-array}{(FLOAT\_ARRAY
\var{float\_array}, INTEGER \var{index})}
returns a \code{Term *} containing the  \code{FLOAT} (in fact it is a double)
stored in the array \var{float\_array} at \code{INTEGER} \var{index}.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{INTEGER}{get-float-array-size}{(FLOAT\_ARRAY
\var{float\_array})}
returns a \code{Term *} containing the \code{INTEGER} value of the size of the
\var{float\_array}. 
\end{typeefa}

\begin{typeefa}{Evaluable Function}{INT\_ARRAY}{make-int-array}{(INTEGER \var{size})}
returns a \code{Term *} containing a \code{INT\_ARRAY} of size \var{size}.
This function should be used in a Special Action.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{INTEGER}{get-int-array}{(INT\_ARRAY
\var{int\_array}, INTEGER \var{index})}
returns a \code{Term *} containing the  \code{INTEGER} stored in the array
\var{int\_array} at \code{INTEGER} \var{index}. 
\end{typeefa}

\begin{typeefa}{Evaluable Function}{INTEGER}{get-int-array-size}{(INT\_ARRAY
\var{int\_array})}
returns a \code{Term *} containing the \code{INTEGER} value of the size of
the \var{int\_array}.
\end{typeefa}

\subsection{OP Instance Related Evaluable Functions}
\node{OP Instance Related Evaluable Functions}
\cpindex{OP Instance Related Evaluable Functions}

These evaluable functions are used to access various information about a OP Instance.

\begin{typeefa}{Evaluable Function}{Term *} {property-of} {(ATOM property, TT\_OP\_INSTANCE)} 
returns the Term which is bound to the property \var{property} in the
op-instance. 
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST of op-instance} {fact-invoked-ops-of}
{(LISP\_LIST)}  
is the fact-invoked-ops-of function. It is defined for 1 term of type
\code{LISP\_LIST}. It returns a \code{LISP\_LIST} containing the OP Instances
which are invoked by a fact. 
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST of op-instance}
{get-the-decision-procedures-of} {(LISP\_LIST of op-instance)} 
returns a \code{LISP\_LIST} containing all the OP Instances of the
\code{LISP\_LIST} which have the property \code{decision-procedure} \code{TRUE}.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{TT\_GOAL or term} {op-instance-goal} {(TT\_OP\_INSTANCE)}
is the op-instance-goal function. It is defined for 1 term. It returns a
\code{TT\_GOAL} containing the goal which leads to the application of this OP
Instance, or returns the symbol NIL if it was invoked by a fact.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST of op-instance} {safety-handlers-of}
{(LISP\_LIST of op-instance)}
is the safety-handlers-of function. It is defined for 1 term
\code{LISP\_LIST}. It returns the list of OP Instances which have the property
\code{SAFETY-HANDLER} set.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST of op-instance} {preferred-of}
{(LISP\_LIST of TT\_OP\_INSTANCE)} 
is the preferred-of function. It is defined for 1 term \code{LISP\_LIST}. It
returns the list of OP Instances which have the property \code{PREFERRED}
set.
\end{typeefa}

\subsection{Fact and Goal Related Evaluable Functions}
\node{Fact and Goal Related Evaluable Functions}
\cpindex{Fact and Goal Related Evaluable Functions}

These evaluable functions are used to access various information about facts
and goals.

\begin{typeefa}{Evaluable Function}{GTEXPRESSION}{GOAL-STATEMENT}{GOAL}
will return the GTEXPRESSION of the GOAL.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{GEXPRESSION}{FACT-STATEMENT}{FACT}
will return the GEXPRESSION of the FACT.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{ATOM}{GSTATEMENT-PREDICAT}{GTEXPRESSION}
return the predicat of the GTEXPRESSION as an ATOM.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{ATOM}{FSTATEMENT-PREDICAT}{GEXPRESSION}
return the predicat of the GEXPRESSION as an ATOM.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{Any Term}{GSTATEMENT-ARG}{GTEXPRESSION, INTEGER \var{pos}}
returns the \var{pos}'th argument of the GTEXPRESSION.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{Any Term}{FSTATEMENT-ARG}{GEXPRESSION, INTEGER
\var{pos}}
returns the \var{pos}'th argument of the GEXPRESSION.
\end{typeefa}

\subsection{Intention Related Evaluable Functions}
\node{Intention Related Evaluable Functions}
\cpindex{Intention Related Evaluable Functions}

These evaluable functions are used to access various information about Intentions.

\begin{typeefa}{Evaluable Function}{LISP\_LIST of intentions}
{get-intended-decision-procedures} {()} 
returns a \code{LISP\_LIST} containing all the intentions of the intention graph
which top level op-instance has the property \code{decision-procedure} true.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{INTEGER} {number-of-intentions} {()}
returns an \code{INTEGER} which is the number of intentions in the
intention-graph.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{TT\_INTENTION} {get-current-intention} {()}
returns a \code{TT\_INTENTION} containing the current intention.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST of Intentions} {get-all-intentions} {()}
returns a \code{LISP\_LIST} containing all the intentions of the intention graph.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST of Intentions} {get-other-intentions} {()}
returns a \code{LISP\_LIST} containing all the intentions of the intention graph,
except the current intention.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST of Intentions} {get-sleeping-intentions} {()}
returns a \code{LISP\_LIST} containing all the intentions of the intention graph,
which are sleeping.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST of Intentions}  {get-root-intentions} {()}
returns a \code{LISP\_LIST} containing all the intentions  which are root of the
intention graph.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{TT\_INTENTION} {find-intention-id} {(ATOM
\var{tag})} 
returns a \code{TT\_INTENTION} containing an intention if there is at least one
intention of the intention graph, which have been tagged with the \code{ATOM}
\var{tag}, and returns NULL otherwise.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST of Intentions} {find-intentions-id} {(ATOM \var{tag})}
returns a \code{LISP\_LIST} containing all the intentions of the intention graph,
which have been tagged with the \code{ATOM} \var{tag}.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{INTEGER} {get-intention-priority}{(TT\_INTENTION)}
returns the priority of the intention.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{INTEGER} {get-intention-time}{(TT\_INTENTION)}
returns the time (date of creation) of the intention.
\end{typeefa}

\subsection{Time Related Evaluable Functions}
\node{Time Related Evaluable Functions}
\cpindex{Time Related Evaluable Functions}

\begin{typeefa}{Evaluable Function}{INTEGER} {time} {()}
returns an \code{INTEGER} which is the number of seconds since some defined
time. In fact, the time origin is of no importance as it is the difference
between two calls which is important.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{INTEGER} {mtime} {()}
returns an \code{INTEGER} which is the number of milliseconds since sometime...
(in any case, it is the difference with another call which is important).
\end{typeefa}

\begin{typeefa}{Evaluable Function}{INTEGER} {USER-CLOCK-TICK} {()}
returns an \code{INTEGER} which is the number of machine TICK spent in user
code used by the \COPRS{} process since it started (\code{CLK\_TCK}, defined in
\file{<time.h>}, is the number of TICK per seconds).
\end{typeefa}

\begin{typeefa}{Evaluable Function}{INTEGER} {SYS-CLOCK-TICK} {()}
returns an \code{INTEGER} which is the number of machine TICK spent in system
code (i.e.\ system calls) used by the \COPRS{} process since it started
(\code{CLK\_TCK}, defined in \file{<time.h>}, is the number of TICK per seconds).
\end{typeefa}

\begin{typeefa}{Evaluable Function}{INTEGER} {USER-SYS-CLOCK-TICK} {()}
returns an \code{INTEGER} which is the number of machine TICK spent in system
AND in user code used by the \COPRS{} process since it started (\code{CLK\_TCK},
defined in \file{<time.h>}, is the number of TICK per seconds).
\end{typeefa}

\subsection{Lisp Evaluable Functions}
\node{Lisp Evaluable Functions}
\cpindex{Lisp Evaluable Functions}

The following functions are defined for LISP like objects (for more information
\pxref{Lisp and Lisp-like Functions}). The functions \code{car} and \code{cdr}
are  the basic access functions in LISP. The \code{car} returns the first
element of a list, and the \code{cdr} returns the rest of the list (i.e.\ the
list without the first element).

For example in Lisp, if the list \code{l} is equal to \code{(a b c)}, then
\code{(car l)} return \code{a}, and \code{(cdr l)} returns \code{(b c)}. There
are then some convenience functions which are provided. They are built following
the following scheme: \code{c[a|d]+r}. For example \code{(caddr l)}, is
equivalent to: \code{(car (cdr (cdr l)))} which in our case returns \code{c}.
\COPRS{} provide all \code{c[a|d]+r} with at most three \code{a} or \code{d}.

\begin{typeefa}{Evaluable Function}{LISP\_LIST}{cons}{(Any Term LISP\_LIST)}
is the cons function. It is defined for 2 terms, a \code{Any Term} and a
\code{LISP\_LIST}.  It returns the new \code{LISP\_LIST}.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST}{cons-tail}{(Any Term LISP\_LIST)}
is defined for 2 terms, a \code{Any Term} and a \code{LISP\_LIST}.  It adds the
\code{Any Term} at the end of the \code{LISP\_LIST}.  It returns the new
\code{LISP\_LIST}.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{Any Term}{car}{(LISP\_LIST)}
is defined for 1 term \code{LISP\_LIST}. It returns the car (or first) \code{Any Term} of
the \code{LISP\_LIST}.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST}{cdr}{(LISP\_LIST)}
is defined for 1 term \code{LISP\_LIST}. It returns the cdr (or rest) \code{LISP\_LIST} of
the \code{LISP\_LIST}.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{Any Term}{caar}{(LISP\_LIST)}
is defined for 1 term \code{LISP\_LIST}. It returns the caar \code{Any Term} of the
\code{LISP\_LIST}.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{Any Term}{cadr}{(LISP\_LIST)}
is defined for 1 term \code{LISP\_LIST}. It returns the cadr (or second) \code{Any Term}
of the \code{LISP\_LIST}.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST}{cdar}{(LISP\_LIST)}
is defined for 1 term \code{LISP\_LIST}. It returns the cdar \code{LISP\_LIST} of the
\code{LISP\_LIST}.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST}{cddr}{(LISP\_LIST)}
is defined for 1 term \code{LISP\_LIST}. It returns the cddr \code{LISP\_LIST} of the
\code{LISP\_LIST}.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{Any Term}{caaar}{(LISP\_LIST)}
defined for 1 term \code{LISP\_LIST}. It returns the caaar \code{Any Term} of the
\code{LISP\_LIST}.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{Any Term}{cadar}{(LISP\_LIST)}
is defined for 1 term \code{LISP\_LIST}. It returns the cadar \code{Any Term} of the
\code{LISP\_LIST}.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST}{cdaar}{(LISP\_LIST)}
is defined for 1 term \code{LISP\_LIST}. It returns the cdaar  \code{LISP\_LIST} of the
\code{LISP\_LIST}.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST}{cddar}{(LISP\_LIST)}
is defined for 1 term \code{LISP\_LIST}. It returns the cddar \code{LISP\_LIST} of the
\code{LISP\_LIST}.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{Any Term}{caadr}{(LISP\_LIST)}
is defined for 1 term \code{LISP\_LIST}. It returns the caaar \code{Any Term} of the
\code{LISP\_LIST}.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{Any Term}{caddr}{(LISP\_LIST)}
is defined for 1 term \code{LISP\_LIST}. It returns the caddr \code{Any Term} of the
\code{LISP\_LIST}.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST}{cdadr}{(LISP\_LIST)}
is defined for 1 term \code{LISP\_LIST}. It returns the cdadr \code{LISP\_LIST} of the
\code{LISP\_LIST}.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST}{cdddr}{(LISP\_LIST)}
is defined for 1 term \code{LISP\_LIST}. It returns the cdddr
\code{LISP\_LIST} of the \code{LISP\_LIST}.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{Any Term}{first}{(LISP\_LIST)}
is the first function. It is defined for 1 term \code{LISP\_LIST}. It returns the
first (or car) \code{Any Term} of the \code{LISP\_LIST}.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{Any Term}{second}{(LISP\_LIST)}
is the second function. It is defined for 1 term \code{LISP\_LIST}. It returns
the second (or cadr) \code{Any Term} of the \code{LISP\_LIST}.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{Any Term}{last}{(LISP\_LIST)}
 is defined for 1 term \code{LISP\_LIST}. It returns the last \code{Any Term} of
 the \code{LISP\_LIST}. An error will occur if the list is empty.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{Any Term}{nth}{(Integer LISP\_LIST)}
 returns the nth \code{Any Term} of
 the \code{LISP\_LIST}, indexed from zero. An error will occur if the first argument is not an
integer or the list is empty.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST}{delete-from-list}{(Any Term, LISP\_LIST)}
returns a new \code{LISP\_LIST} which is the one passed in argument in which all
instance of \code{Any Term} have been removed. The order in the list is not preserved.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST}{list-difference}{(LISP\_LIST
LISP\_LIST)}
is the list-difference function. It is defined for 2 terms each of them
being a \code{LISP\_LIST}. It returns a new \code{LISP\_LIST} which is the difference
between the first one and the second one.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST}{list-intersection}{(LISP\_LIST
LISP\_LIST)} is defined for two \code{LISP\_LIST} terms. It returns a
\code{LISP\_LIST} which is the intersection of the two \code{LISP\_LIST}.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST}{list-union}{(LISP\_LIST
LISP\_LIST)} is defined for two \code{LISP\_LIST} terms. It returns a
\code{LISP\_LIST} which is the union of the two \code{LISP\_LIST}.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST}{list-difference-order}{(LISP\_LIST LISP\_LIST)}
is the list-difference function. It is defined for 2 terms each of them
being a \code{LISP\_LIST}. It returns a new \code{LISP\_LIST} which is the difference
between the first one and the second one, with the element in the same
order than in the first one.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{INTEGER}{length}{(LISP\_LIST)}
is the length function. It is defined for 1 term. It returns an \code{INTEGER},
the length of the \code{LISP\_LIST}.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{Any Term}{select-randomly}{(LISP\_LIST)}
is the select-randomly function. It is defined for 1 term \code{LISP\_LIST}. It
returns one of its elements (a \code{Any Term}) chosen randomly.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST}{reverse}{(LISP\_LIST)}
is the reverse function. It is defined for 1 term \code{LISP\_LIST}. It returns the
reverse of the \code{LISP\_LIST}.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST}{sort-alpha}{(LISP\_LIST of terms)}
is a sorting function. It is defined for 1 term \code{LISP\_LIST}. It returns the
same list with its element sorted alphanumericaly.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST}{l-list}{(TermList \var{terms})}
is the l-list function. It is defined for n terms. It returns the
\code{LISP\_LIST} containing all the TermList terms. The difference with the
\code{(.} and \code{.)} reader (which can also be used to build \code{LISP\_LIST})
is that the elements will be evaluated.
\end{typeefa}

\subsection{Miscellaneous Evaluable Functions}
\node{Miscellaneous Evaluable Functions}
\cpindex{Miscellaneous Evaluable Functions}

\begin{typeefa}{Evaluable Function}{ATOM}{gensym}{()}
is the traditional gensym function (which create a new unique symbol in Lisp) .
It is defined for no argument. It returns a new unique \code{ATOM}.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{STRING}{sprintf}{(COMPOSED\_TERM \var{term})}
will return a \code{STRING} which is the result of the formatted print directives (see Printing Actions like printf).
\end{typeefa}

\begin{typeefa}{Evaluable Function}{STRING}{string-cat}{(STRING STRING)} 
will return a \code{STRING} which is the concatenation of the two
\code{STRING}s passed as argument.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{STRING}{term-string-cat}{(TermList \var{terms})} 
  will return a \code{STRING} which is the concatenation of all the terms
  passed as argument.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{Any Term}{val}{(Any Term)}
is defined for 1 argument. It return this argument as is, without any
modification. This function is very useful to force retrieving the value of a
program variable so it is not bound again by the database/OP execution.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{Term *}{ff-val}{(VARIABLE GEXPRESSION)}
is defined for 2 terms, a \code{VARIABLE} and a \code{GEXPRESSION}. It is used
to retrieve the value of a functional fact.  For example, if \code{POSITION}
has been declared functional fact 1 (with \code{declare ff position 1}).  Then
calling \code{(FF-VAL \$X (POSITION VALVE \$X))} will return the current
\code{Term *} position of the \code{VALVE}.  It returns the \code{ATOM}
\code{NIL} if the predicate has not been declared as functional 
fact, or if no value were found. This makes it indistinguishable from a
\code{NIL} real value.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST}{all}{(VARIABLE GEXPRESSION)}
is the all function. It is defined for 2 terms, a \code{VARIABLE} and a
GEXPRESSION.  It returns a \code{LISP\_LIST} containing all the possible and
unique bindings of \code{VARIABLE} for which the GEXPRESSION is true in the
database. \pxref{Universal Quantification of Variables} for more information on
this subject.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST of LISP\_LIST}{n-all}{(LENV GEXPRESSION)}
is the n-all function. It is defined for 2 terms, a \code{LISP\_LIST} (a
Lisp list of
\code{VARIABLE}s) and a GEXPRESSION. It returns a \code{LISP\_LIST} of
\code{LISP\_LIST} (in the same order as they are defined in LENV) containing all
the possible bindings of \code{LENV} for which the GEXPRESSION is true in the
database. N-ALL is used in OPs such as in \code{(! (... (n-all (. \$x \$y .) (foo \$y
\$x)) ...  ))}, which returns the \code{LISP\_LIST} of \code{LISP\_LIST}
containing the bindings of the \code{LENV} (example: if we have \code{(foo 1
2)} and \code{(foo 3 4)} in the database, returns \code{(.(.  2 1 .) (. 4 3
.).))} which satisfies \code{(foo \$y \$x)}. \xref{Universal Quantification of Variables} for more information on this subject.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST of LISP\_LIST}{n-all-list}{(LENV GEXPRESSION)}
is the n-all-list function. It is defined for 2 terms, a \code{LISP\_LIST}
(a Lisp list of
\code{VARIABLE}) and a GEXPRESSION. It returns a \code{LISP\_LIST} of
\code{LISP\_LIST} (in the same order as they are defined in \code{LENV}) each
containing the bindings of the variable in \code{LENV} for which the
GEXPRESSION is true in the database.  N-ALL-LIST is used in OPs such as in
\code{(! (... (n-all-list (\$x \$y) (foo \$y \$x)) ...  ))}, which, if we have
\code{(foo 1 2)} and \code{(foo 3 4)} in the database, returns: \code{(.(.  1 3
.) (. 2 4 .).))}. \xref{Universal Quantification of Variables} for more
information on this subject. 
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST}{all-pos}{(INTEGER EXPRESSION)}
is defined for 2 terms, an \code{INTEGER} and a
GEXPRESSION.  It returns a \code{LISP\_LIST} containing all the Terms in
\code{INTEGER}'th position in all the Expression matching \code{EXPRESSION}
passed as argument.
\end{typeefa}

\begin{typeefa}{Evaluable Function}{LISP\_LIST of GEXPRESSION}{mention}{(AnyTerm)}
is defined for 1 terms.  It returns a \code{LISP\_LIST} containing all the
expressions in the database which mention the AnyTerm (even as a predicat or a
function name).
\end{typeefa}

\subsection{Goal Building Evaluable Functions}
\node{Goal Building Evaluable Functions}
\cpindex{Goal Building Evaluable Functions}

These functions can be used to create goals which can then be intended with the
appropriate actions (\pxref{Intending Goal Actions}, and  \pxref{Intending Goals Directly}). 

\begin{typeefa}{Evaluable Function}{TT\_GOAL} {build-goal}{(GTEXPRESSION)}
is defined for 1 term containing a Gtexpression. It returns a
\code{TT\_GOAL} containing a goal which can then be intended directly with the
appropriate goal intending actions (\pxref{Intending Goal Actions}).
\end{typeefa}

\begin{typeefa}{Evaluable Function}{GTEXPRESSION} {apply-subst-in-gtexpr}{(VARIABLE
AnyTerm GTEXPRESSION)}
is defined for 3 terms: a variable, a Term, and a
gtexpression. It returns a term containing a Gtexpression,
in which all occurrences of the variable is replaced by the term. 
\end{typeefa}

\begin{typeefa}{Evaluable Function}{TT\_GOAL} {apply-subst-in-goal}{(VARIABLE AnyTerm GTEXPRESSION)}
is defined for 3 terms: a variable, a Term, and a gtexpression. It returns a
\code{TT\_GOAL} containing a goal (created from the GTEXPRESSION passed in the
arguments list), and in which all occurrences of the variable is replaced by
the term.  The goal obtained can then be intended directly with the appropriate
goal intending actions (\pxref{Intending Goal Actions}).
\end{typeefa}

\section{How to Define your Own Evaluable Functions}
\node{How to Define your Own Evaluable Functions}
\cpindex{How to Define your Own Evaluable Functions}

It is fairly easy to define your own evaluable functions. To do so, you
have to write a C (or in any language you can link the object code with)
function which takes a list of terms (TermList) as arguments and returns a
pointer to a new Term. It is in fact critical that the \code{Term *} returned be
a pointer to a NEW Term. Using the list library functions you can then access
the element of the TermList and compute the returned value (\pxref{Library and Kernel Functions}).

You will find various examples of user-defined evaluable functions and
actions in the file: \file{user-ev-function.c}. Here is a simple example of
such function.

\begin{verbatim}
Term *toto_eval_func(TermList terms)
{
     Term *t1, *res;

     res = MAKE_OBJECT(Term);

     t1 = (Term *)get_list_pos(terms, 1);
     res->type = INTEGER;
     res->u.intval = my_function(t1);

     return res;
}
\end{verbatim}

You can define as many evaluable functions as you want.  You need to
declare them in the kernel, as well as their external name (as it will
appear in the OPs), and the number of arguments they take. This
declaration is made in the body of the \code{declare\_user\_eval\_funct}
function which is called upon start up of the kernel.

\begin{verbatim}
void declare_user_eval_funct(void)
{
     make_and_declare_eval_funct("TOTO", toto_eval_func, 1);
     return;
}
\end{verbatim}

\begin{typefn}{Kernel User Function}{void}{make\_and\_declare\_eval\_funct}
{(Function \var{name}, PFPT \var{funct}, int \var{ar})}
is used to declare the evaluable function. You have to specify the function
name, the C function which implements it, and the arity of this function.
\end{typefn}

\begin{typefn}{Kernel User Function}{void}{declare\_user\_eval\_funct} {(void)}
is the function in which you must put your call to
\code{make\_and\_declare\_eval\_funct}. It is called upon start-up by the
kernel and builds the appropriate table to map the actions and evaluable
functions names and the corresponding C function.  Note that the user can
redefine the predefined evaluable functions or actions by using their
name.
\end{typefn}

\chapter{Procedure Execution and Run Time}
\node{Procedure Execution and Run Time}
\cpindex{Procedure Execution and Run Time}



\section{Run Time}
\node{Run Time}
\cpindex{Run Time}

\figuregif[height=0.3\textheight]{run-time}{C Procedural Reasoning System main loop}{oprsrt}

As shown on figure \ref{oprsrt}, the \CPK{} runs the entire system. From a
conceptual standpoint, it operates in a relatively simple way. At any
particular time, certain goals are established and certain events occur
that alter the beliefs held in the system database (1). These changes in
the system goals and beliefs trigger (invoke) various OPs (2). One or more
of these applicable OPs are then chosen and placed on the intention
structure (3). Finally, OPRS selects a task (intention) from the root of
the intention structure (4) and executes \dfn{one step} of that task (5).
This results either in the performance of a primitive action (6), the
establishment of a new subgoal, or the conclusion of some new belief (7).

At this point the interpreter cycle starts again: the newly established
goals and facts (if any) trigger new OPs, one or more of these are
selected and placed on the intention structure, and again an intention is
selected from that structure and partially executed.

\section{Intention Graph}
\node{Intention Graph}
\cpindex{Intention Graph}

The Intention Graph is one of the most important component of the \CPK{}.
It holds all the intentions/tasks which are currently ``active''. Think of
it as the graph of all the tasks upon which the \CPK{} works at one point.

These tasks are supposedly more or less independent. In other words, they
should be working on their own problem, satisfying their own goal, responding
to some events.

\figuregif[scale=0.5]{intention-graph}{Intention Graph Development}{int-graph}

\figuregif[scale=0.5]{xoprs-fact-int-graph}{Intention Graph Development}{int-graph2}

% ******* rajouter plusieurs exemples de int graph

Each task or intention can be visualized under the \XPK{}, if you have selected
the intention graphic trace. It is represented as a box, containing the name of
the top OP in this task (i.e.\ the one which was intended in this new task or
intention) and the goal or the fact which is ``responsible'', or which
triggered this OP, and lead to this intention.

This set of tasks is represented as a graph (which can be displayed in the
\XOPRS{} as shown on figure \ref{int-graph} and figure \ref{int-graph2}). Only
the roots of this graph can be executed. The other tasks, or intentions, must
wait until they become root themselves before they can be executed. In other
words, the precedence relation in this graph can be interpreted as a blocking
relation. A task or intention cannot be executed until all other tasks before
it disappear in the graph.  This, for example, can be used by the user to
create a new task which, if placed in front of the other tasks, will be
executed before all the other ones.  Moreover, the other tasks will resume
their activity only when the new root has finished. For example, Figure
\ref{int-graph} shows an example of an intention graph. Each intention is
represented with a box which specifies the name of the procedure, as well as
the fact or the goal responsible for its activity (i.e.\ the goal or the fact
which lead to its execution). In this particular example, there are six tasks
represented. The root of the graph is executing a meta level OP and is placed
in front of another meta level OP which execution has been interrupted. These 2
meta level OPs are in front of four tasks which will resume/start their
execution as soon as the two meta level OP are done.

Note that you can have more than one root in the intention graph. In this
case, the system can utilize a user-defined mechanism to decide which
intention should be the current intention, i.e.\ the one to be executed
(see \pxref{Intention Graph Sorting Predicate}). You can use priority
(there is in fact a priority slot in each task), or date of creation, or
whatever you think is the best heuristic to execute this intention.

The current intentions are the one which has been chosen to execute. If
you have selected the intention graphic trace in \XPK{}, these intentions
are recognizable because of the two small arrows surrounding their name.

Other intentions can be in three different states.

\begin{itemize}

\item They can be executable, in which case, they can be selected as the
current intention if they are among the roots of the graph.

\item They can be sleeping, which means that the most recent goal they
posted was a wait goal and it has not been achieved yet (a S is visible on
the graphic trace for task in this state).


\item They can be awakening, which means that they were sleeping and the
condition they were waiting to become true has just became true. As a result, they will 
receive some processing cycle time in the main loop and will become the current
intention, if they are among roots of the graph.

\end{itemize}

It is important to note that each intention on the intention graph
(appearing as a task box within the Intention Structure shown in Figure
\ref{oprsrt}) represents an entire stack of invoked OPs (procedures).  In
particular, as each OP is executed, it establishes certain subgoals.
These subgoals, in turn, invoke other OPs, and so on.  All the OPs so
invoked form a runtime procedure stack, much like the runtime stack of so
called subroutines in conventional programming languages.  Where the
system has only one task to perform, there is only one such stack, and
consequently one task box.  But where the system needs to perform multiple
tasks, it spawns multiple run time stacks, executing, suspending, and
resuming these in much the same manner as processes are handled in an
operating system.

\section{Multi Threads Execution}
\node{Multi Threads Execution}
\cpindex{Multi Threads Execution}

\figuregif[scale=0.5]{par-surv}{A OP with multiple threads.}{moving}

Multi-threads execution is linked to parallel execution in OPs. As
described earlier, it is a very versatile mechanism which can be used to
parallelized operations in a procedure. However, it is usually used for
operations and actions performed in the same task, intention, i.e.\ working on a
particular goal, or responding to a particular event. For example, Figure
\ref{moving} shows a OP with two threads which are both needed to perform the
goal specified in the invocation part. There are a number of OPRS runtime
options linked to this mechanism, to enable/disable parallel posting of goals
and parallel intending of OPs.

\section{\CPK{} Main Loop}
\node{OPRS Kernel Main Loop}
\cpindex{OPRS Kernel Main Loop}

The OPRS main loop consists of one inner meta level reasoning loop
inside the main loop. The inner loop determines
the successive Sets Of Applicable OPs (SOAK), within the context of
concluded beliefs on the previous SOAK. The inner loop stops when no
applicable OPs are found, i.e.\  when the SOAK is empty.

The code of the OPRS main loop is provided below to show how meta level OPs are 
executed.

\begin{verbatim}
while (TRUE) {        /* Loop for ever. */
    check_stdin();    /* Check the input buffer. */
    shift_facts_goals(); /* Get new facts and new goals. */

    soak = find_soak();  /* Look for new applicable OPs. */

    while (!(list_empty(soak))) { /* While we have Applicable OPs. */
        post_soak_meta_fact(soak, oprs); /* Post the Meta Facts. */
        previous_soak = soak; /* Save the previous soak value. */

        shift_facts_goals(oprs);
        soak = find_soak(oprs);
    }

    if (!(list_empty(previous_soak))) { /* soak empty but previous soak non empty */
        post_soak_meta_fact(soak);
        if (parallel_intend) /* If parallel intending */
            intend_all(previous_soak); /* Intend all of them. */
        else
            intend(select_randomly(previous_soak));/* Intend one randomly. */
    }
    current_intention = choose_intention(); /* Choose an intention to execute. */
    execute_intention(current_intention); /* Execute one step of the intention. */

    previous_soak = soak;
}
\end{verbatim}

When OPs are not being executed, the main loop is idle. However, the
kernel monitors new events (coming from the \MPA{} or from the
\OPRSS{}). In addition, one or more OPs might be sleeping and waiting for particular 
conditions to become true. The \OPRSS{} kernel will wake up
every \code{main\_loop\_pool\_sec + main\_loop\_pool\_usec} (seconds and
milliseconds) to check if conditions have become true, and awake the appropriate OP.

Every \code{main\_loop\_pool\_sec +
main\_loop\_pool\_usec}, the conditions which may have change ``by themselves'',
like evaluable predicates depending on external conditions are checked. For
example, if you have written an evaluable predicate which tells if yes or no a
particlar tank is full or not, a waiting condition on this predicate will be at
least evaluated every \code{main\_loop\_pool\_sec +main\_loop\_pool\_usec}. As a
consequence, putting a too small value (such as 0 seconds + 10 milliseconds)
will put a higher burden on the kernel execution.

\section{OP Applicability}
\node{OP Applicability}
\cpindex{OP Applicability}

The triggering mechanism, i.e.\  the mechanism which finds the currently
applicable OPs, has been optimized for dynamic environments. The syntax and semantics
of OPs require the Invocation Part to specify a goal or fact condition that will trigger the 
execution of the OP. In other words, only the occurrence of one of
these goals or facts may render this OP applicable. When the procedures are
loaded and compiled in the system, hashtables are built and
used by the kernel to quickly retrieve (in constant time) the
procedures which are triggered by a particular fact or a particular goal.
Therefore, the kernel does not have to scan the whole library of procedures
for applicable procedures, but only a subset of those procedures which are
``relevant'' to a new fact or a new goal. Of course, this does not prevent
the system from using a full unification to check the applicability of the
relevant procedures afterwards, but this is then done on a very small
subset of the set of OPs.

\section{Intending OP}
\node{Intending OP}
\cpindex{Intending OP}

The action of intending a OP instance, i.e.\ deciding to execute it is a very
important step in \CXPK{} main loop. No OP is executed before it is intended.
Moreover, as seen above, there is only one way to intend a OP: when
the current set of applicable OPs is empty, it intends all the OPs in the
previous set of OPs or chooses one randomly in the previous set of applicable OPs,
depending on the value of the \code{set parallel intend} (\pxref{OPRS Kernel
Meta Level Option Commands}).  Note, however, that applicable OPs can be intended by 
meta level OPs that are currently executing.

\section{Using Action OPs}
\node{Using Action OPs}
\cpindex{Using Action OPs}

Action OPs are the basic or primitive actions of the
system. Their activity range from actions such as printing a value on the
screen, sending messages to another \COPRS{}, through opening the valve of a
system under \COPRS{} control. Action OPs produce some type of
activity which is implemented using a C function (or any external code
linked to
the \CPK{}).

There are two types of action OP (\pxref{Using Action OPs}). Standard action
(\pxref{Standard Action}) and Special action (\pxref{Special Action}).

When you define an action OP, you need to specify which C function needs
to be called whenever this action OP is executed. This is very similar to
defining evaluable functions.



\subsection{Predefined Actions}
\node{Predefined Actions}
\cpindex{Predefined Actions}

All evaluable functions return a \code{Term *}. However, this term
can contain different types of objects (\pxref{Terms}). In the following
description, we will indicate which type of object is contained in the
\code{Term *} returned by the evaluable function. In addition, all the
evaluable functions take a \code{TermList} as an argument. Whenever it is
possible, we will specify the number of arguments and the type of the
\code{Term} for each element.

To help the reader understand the descriptions for the evaluable functions
in the following section, consider the \code{send-message} action:

\begin{typeefa}{Action}{ATOM}{send-message}{(ATOM GEXPRESSION)}
is the send-message function. It is defined for two terms, an \code{ATOM}, the
name of the recipient, and a GEXPRESSION (which must be an EXPRESSION).
\end{typeefa}

The \code{ATOM} before the function name \code{send-message} is the type of the
object contained in the \code{Term *} object that is returned by this
\code{send-message} function.  The \code{(ATOM GEXPRESSION)} after the function
name specifies the type of the object contained in the TermList which is the
argument to the \code{send-message} function. In this case, it means at two
argument an \code{ATOM} (the name of the recipient) and a \code{GEXPRESSION}
(the message itself).

Most predefined actions have a corresponding OP in \file{new-default.opf},
\file{meta-intended-goal.opf} or \file{new-meta.opf} (\pxref{Default OPs}).

Predefined actions can be sorted in various categories:



\subsubsection{Printing Actions}
\node{Printing Actions}
\cpindex{Printing Actions}

These actions are used to print objects in various format.

\begin{typeefa}{Action}{ATOM}{print}{(ANY\_TERM \var{term})} is the print
function. It is defined for 1 term. It prints the object and a cariage return.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{print-inside}{(COMPOSED\_TERM \var{term})}
is defined for 1 term. The format of the term passed as argument is somewhat
awkward and is here for upward compatibility with the old Lisp version of
\OPRS{}. The Term should look like this: \\*
\code{(FORMAT NIL "The Factorial of \~{}a is \~{}a." \$X \$N)))}\\*
i.e.\ a list containing the word \code{FORMAT}, then the symbol
\code{NIL}, then a string, and finally a number of variables or terms.
The \samp{\~{}a} in the string will be replaced at print time with the value of
the corresponding terms or variables.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{printf}{(COMPOSED\_TERM \var{term})}
is defined for 1 term. The format of the term passed as argument is somewhat
awkward but similar to the C format directive. 
The Term should look like this: \\*
\code{(FORMAT "The Factorial of  \%d is \%d." \$X \$N)))}\\*
i.e.\ a list containing the word \code{FORMAT}, then a string, and finally a
number of variables or terms.  The \samp{\%d} in the string will be replaced at
print time with the value of the corresponding terms or variables. The
following directives are supported: \samp{\%g}, \samp{\%d}, \samp{\%f} and
\samp{\%s}. 
It does not print a carriage return at the end of the string.
NEW DJM: The directive \samp{\%t} is like 
\samp{\%s} except that it will preserve the double-quotes around strings...this is useful
for writing out PRS terms that can be read back in again.  Hence 't' for term.
\end{typeefa}

\subsubsection{Input Actions}
\node{Input Actions}
\cpindex{Input Actions}

\begin{typeefa}{Action}{undefined}{read-inside}{()}
is the read-inside function. It is defined for no term. It returns the
symbol read on the input. In fact, to make the read asynchronous, this
function is currently implemented using a fact which is posted by the
user.  This fact is the basic events fact (\pxref{Basic Events}),
\code{(READ-RESPONSE <response>)}, it will wake up the read action which
will return the term \code{<response>}.
\end{typeefa}

\begin{typeefa}{Action}{undefined}{read-inside-id}{(ATOM \var{id})}
is the read-inside-id function. It is defined for one term, an \code{ATOM}. This
function will wait for the fact : \code{(READ-RESPONSE-ID id <response>)}, and
returns the term \code{<response>}.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{read-inside-id-var}{(ATOM \var{id} undefined \var{response})}
is the read-inside-id-var function. It is defined for two
terms an \code{ATOM} \var{id} and an undefined Term \var{response}.  This
function will wait for the fact : \code{(READ-RESPONSE-ID id <response>)}, if
the term \var{response} given as second argument is an unbound variable it
will bind it to the <response>, else it will wait until a fact unifies it.
\end{typeefa}

\subsubsection{Array Manipulation Actions}
\node{Array Manipulation Actions}
\cpindex{Array Manipulation Actions}

\begin{typeefa}{Action}{ATOM}{set-float-array}{(FLOAT\_ARRAY \var{float\_array},
INTEGER \var{index}, FLOAT \var{value})}
will store the \code{FLOAT} \var{value} at index \var{index} in the array
\var{float\_array}.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{set-int-array}{(INT\_ARRAY \var{int\_array},
INTEGER \var{index}, INTEGER \var{value})}
will store the \code{INTEGER} \var{value} at index \var{index} in the array
\var{int\_array}.
\end{typeefa}

\subsubsection{Intending OP Instance Actions}
\node{Intending OP Instance Actions}
\cpindex{Intending OP Instance Actions}

\begin{typeefa}{Action}{ATOM}{intend-op}{(TT\_OP\_INSTANCE)}
is the intend-op function. It is defined for one term, a \code{TT\_OP\_INSTANCE}. It will intend it, after the current intention.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{intend-op-with-priority}{(TT\_OP\_INSTANCE and INTEGER)}
is defined for two terms, a \code{TT\_OP\_INSTANCE} and an \code{INTEGER}. The OP
Instance will be intended, after the current intention, with the priority
specified in the \code{INTEGER}.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{intend-op-after}{(TT\_OP\_INSTANCE \var{opi}, LISP\_LIST of intentions \var{after})}
is defined for two terms, a \code{TT\_OP\_INSTANCE} and a \code{LISP\_LIST} of
intentions. It will intend \var{opi} after all the intentions in
\var{after}.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{intend-op-with-priority-after}{(TT\_OP\_INSTANCE \var{opi}, INTEGER \var{priority}, LISP\_LIST of intentions \var{after})}
is defined for three terms; \var{opi} a \code{TT\_OP\_INSTANCE},
\var{priority} an \code{INTEGER} and \var{after} a  \code{LISP\_LIST} of intentions. The
\var{opi} will be  intended with the priority \var{priority} after all the
intentions in \var{after}.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{intend-op-before-after}{(TT\_OP\_INSTANCE \var{opi},LISP\_LIST of intentions \var{before}, LISP\_LIST of intentions \var{after})}
is defined for three terms, a \code{TT\_OP\_INSTANCE} \var{opi} which will be
intended, before all the intentions in \var{before} and after all the
intentions in \var{after}.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{intend-op-after-before}{(TT\_OP\_INSTANCE \var{opi}, LISP\_LIST of intentions \var{after}, LISP\_LIST of intentions \var{before})}
is defined for three terms, a \code{TT\_OP\_INSTANCE} \var{opi} which will be
intended, after all the intentions in \var{after} and before all the intentions
in \var{before}.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{intend-op-with-priority-after-before}{(TT\_OP\_INSTANCE \var{opi}, INTEGER \var{priority}, LISP\_LIST of intentions \var{after}, LISP\_LIST of intentions \var{before})}
is defined for four terms, a \code{TT\_OP\_INSTANCE} \var{opi} which will be
intended with the priority \var{priority}, after all the intentions in
\var{after} and before all the intentions in \var{before}.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{intend-all-ops-as-root}{(LISP\_LIST of op-instance)}
is defined for one term, a \code{LISP\_LIST} of op-instance. Each OP
Instance will be intended as a root of the Intention Graph.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{intend-all-ops}{(LISP\_LIST of op-instance)}
is defined for one term, a \code{LISP\_LIST} of op-instance. Each OP Instance will be
intended in the Intention Graph, after the current intention.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{intend-all-ops-after}{(LISP\_LIST of op-instance),
\code{LISP\_LIST} of intentions \var{after})} is defined for two terms, a \code{LISP\_LIST} of
op-instance and \var{after} a \code{LISP\_LIST} of intentions. Each OP Instance will be
intended in the Intention Graph, after all the intentions in \var{after}.
\end{typeefa}

\subsubsection{Intending Goal Actions}
\node{Intending Goal Actions}
\cpindex{Intending Goal Actions}

\begin{typeefa}{Action}{ATOM} {intend-all-goals-//} {(LISP\_LIST of goal)}
is defined for one term, a \code{LISP\_LIST} of goals. Each goal will be intended
in parallel after the current intention.
\end{typeefa}

\begin{typeefa}{Action}{ATOM} {intend-all-goals-//-as-roots} {(LISP\_LIST of
goal)}
is defined for one term, a \code{LISP\_LIST} of goals.
Each goal will be intended as a root of the intention graph.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{intend-all-goals-//-after}{(LISP\_LIST of goal),
LISP\_LIST of intentions \var{after})} is defined for two terms, a \code{LISP\_LIST} of
goals and \var{after} a \code{LISP\_LIST} of intentions. Each goal will be intended in
the Intention Graph, after all the intentions in \var{after}.
\end{typeefa}

\begin{typeefa}{Action}{ATOM} {intend-all-goals-//-as-roots-with-priority}
{(LISP\_LIST of op-instance, LISP\_LIST of Term INTEGER)} is defined for two
terms, a \code{LISP\_LIST} of goals and a \code{LISP\_LIST} of Term \code{INTEGER}.  Each goal will be
intended as a root with the priority specified in the \code{INTEGER} list.
\end{typeefa}

\begin{typeefa}{Action}{ATOM} {intend-all-goals-//-after-roots} {(LISP\_LIST of
goal)} is defined for one term, a \code{LISP\_LIST} of goals. Each goal will be intended
in parallel after the root(s) of the intention graph.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{intend-goal}{(TT\_GOAL \var{goal})}
is defined for one term, a \code{TT\_GOAL} \var{goal} which will be
intended after the current intention.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{intend-goal-with-priority}{(TT\_GOAL
\var{goal}, INTEGER \var{priority})} is defined for two terms, a \code{TT\_GOAL} \var{goal}
which will be intended with the priority \var{priority}, after the current
intention.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{intend-goal-after-before}{(TT\_GOAL
\var{goal},
LISP\_LIST of intentions \var{after}, LISP\_LIST of intentions \var{before})} is
defined for three terms, a \code{TT\_GOAL} \var{goal} which will be intended
after all the intentions in \var{after} and before all the intentions in
\var{before}.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{intend-goal-with-priority-after-before}{(TT\_GOAL \var{goal}, INTEGER \var{priority}, LISP\_LIST of intentions \var{after},
LISP\_LIST of intentions \var{before})}
is defined for four terms, a \code{TT\_GOAL} \var{goal} which will be
intended  with the priority \var{priority}, after all the intentions in
\var{after} and before all the intentions in \var{before}.
\end{typeefa}

\subsubsection{Intentions Manipulation Actions}
\node{Intentions Manipulation Actions}
\cpindex{Intentions Manipulation Actions}

\begin{typeefa}{Action}{ATOM}{tag-current-intention}{ATOM \var{tag}}
will tag the current intention, i.e.\ the intention in which it is executed, with
the \code{ATOM} passed in argument.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{kill-other-intentions}{()}
is defined for no argument. It will kill all the other intentions in the
intention graph, except the current one.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{kill-intentions}{(LISP\_LIST of Intentions)}
will kill all the intentions in the \code{LISP\_LIST}, except itself.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{kill-intention}{(TT\_INTENTION)}
will kill the intention in the \code{TT\_INTENTION}, except itself.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{asleep-intentions}{(LISP\_LIST of Intentions and ATOM \var{wake-up-tag})}
will asleep all the intentions in the \code{LISP\_LIST}, but cannot asleep itself.
Theses intentions will be waked up by the basic event facts (\pxref{Basic  Events}),  \code{(INTENTION-WAKE-UP \var{wake-up-tag})}.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{asleep-intention}{(TT\_INTENTION and ATOM \var{wake-up-tag})}
will asleep the intention in the \code{TT\_INTENTION}, but cannot asleep itself.
This intention will be waked up by the basic event facts (\pxref{Basic Events}),  \code{(INTENTION-WAKE-UP \var{wake-up-tag})}.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{wake-up-intention}{(ATOM \var{wake-up-tag})}
will just post the basic event facts (\pxref{Basic Events}),
\code{(INTENTION-WAKE-UP \var{wake-up-tag})}, to wake up intentions
asleep by asleep-intention or asleep-intentions.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{asleep-intentions-cond}
{(LISP\_LIST of Intentions and GEXPRESSION \var{condition})}
will asleep all the intentions in the \code{LISP\_LIST}, but cannot asleep itself.
Theses intentions will be waked up when the \var{condition} will become true.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{asleep-intention-cond}{(TT\_INTENTION and
GEXPRESSION \var{condition})}
will asleep the intention in the \code{TT\_INTENTION}, but cannot asleep itself.
This intention will be waked up when the \var{condition} will become true.
\end{typeefa}

\begin{typeefa}{Action}{ATOM} {set-intention-priority}{(TT\_INTENTION and
INTEGER \var{new-priority})}
set  the priority of the intention to the value \var{new-priority}.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{apply-sort-predicate-to-all}{()}
is defined for no Term, It will apply the current sorting predicate
(\pxref{Intention Graph Sorting Predicate}), to all the intentions of the
graph. 
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{sort-intention-priority}{()}
is defined for no Term, It will set the sorting predicate (\pxref{Intention Graph Sorting Predicate}), to sort by priority. 
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{sort-intention-time}{()}
is defined for no Term, It will set the sorting predicate (\pxref{Intention Graph Sorting Predicate}), to sort by time (date of 
creation).
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{sort-intention-priority-time}{()}
is defined for no Term, it will set the sorting predicate (\pxref{Intention Graph Sorting Predicate}), to sort by priority then if two intentions have the
same priority, by creation time. 
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{sort-intention-none}{()}
is defined for no Term, It will unset the sorting predicate (\pxref{Intention Graph Sorting Predicate}). 
\end{typeefa}

\subsubsection{Miscellaneous Actions}
\node{Miscellaneous Actions}
\cpindex{Miscellaneous Actions}

\begin{typeefa}{Action}{ATOM}{send-message}{(ATOM GEXPRESSION)}
is the send-message function. It is defined for two terms, an \code{ATOM}, the
name of the recipient, and a GEXPRESSION (which must be an EXPRESSION).
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{broadcast-message}{(GEXPRESSION)}
is the broadcast-message function. It is defined for one term, the
 GEXPRESSION (which must be an EXPRESSION) to send.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{multicast-message}{(LISP\_LIST of ATOM GEXPRESSION)}
 is defined for two term,  the LISP\_LIST of the recipients name (as ATOM) and
 the GEXPRESSION (which must be an EXPRESSION) to send. 
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{send-string}{(ATOM STRING)}
  is defined for two terms, an \code{ATOM}, the name of the recipient, and a
  \code{STRING}, which will be sent to the recipient.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{execute-command}{(STRING)} 
is the execute-command action. It will execute the command (\pxref{OPRS Kernel Commands}), as if it was typed by the user.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{start-critical-section}{()}
is defined for no Term, it will start a critical section (\pxref{Critical Section}). 
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{end-critical-section}{()}
is defined for no Term, it will end the current critical section
(\pxref{Critical Section}). 
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{fail}{()}
Does nothing, just fail, i.e.\ return the \code{nil} symbol. A OP (called
\code{|Fail|}) is defined in \file{new-default.opf} and call this action. This
action can be useful when you need to explicitly fail a branch of execution.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{succeed}{()}
Does nothing, just succeed, i.e.\ return the \code{T} symbol. A OP (called
\code{|Succeed|}) is defined in \file{new-default.opf} and call this action. This
action can be useful when you need an extra edge which does nothing between two nodes.
\end{typeefa}

\begin{typeefa}{Action}{ATOM}{test-and-set}{(GTEXPRESSION)}
is the test-and-set function. It is defined for one \code{GTEXPRESSION}. It
returns the result of posting the \code{GTEXPRESSION} as a goal. Therefore it can
return \code{T}, \code{:wait} or \code{NIL}. This function should only be
used by the |Test and Set| OP. This function has no reason to be ever since the
``IF-THEN-ELSE'' node has been introduced. 
\end{typeefa}

\subsection{How to Define your Own Actions}
\node{How to Define your Own Actions}
\cpindex{How to Define your Own Actions}

It is fairly easy to define your own actions. To do so, you have to write a C
function which takes a list of terms (TermList) as arguments and returns a
pointer to a new Term. It is in fact critical that the \code{Term *} returned be a
pointer to a NEW Term. Using the list library functions you can then access the
element of the TermList and compute the returned value.

The value returned by the evaluation of this function is meaningful. It must be
a pointer to term, and this term will be freed by the caller. If it returns the
term symbol \code{:wait}, the function has not completed its execution and it
should be called again later. If it returns the term symbol \code{nil}, then
the action is considered as failed and the OP failed the goal it was working
on. Any other term value returned is considered as a success, and the action OP
is successful.

Keep in mind that you can define Special Actions which call C functions
defined for evaluable functions (\pxref{Predefined Evaluable Functions}).
However, the compiler will warn you of such practice.

You will find various examples of user-defined evaluable functions and
actions in the file: \file{user-action.c}.

\begin{verbatim}
Term *action_bar_foo(TermList terms)
{
     Term *t1, *t2, *res;

     res = MAKE_OBJECT(Term); /* This will make a Term. */

     t1 = (Term *)get_list_pos(terms, 1);
     t2 = (Term *)get_list_pos(terms, 2);
     if ((t1->type != ATOM) || (t2->type != TERM_COMP))
        fprintf(stderr, "Expecting an ATOM and a TERM_COMP in action_bar_foo.");
     my_action(t2->u.term, t1->u.id);
     res->type = ATOM;
     res->u.id = lisp_t_sym;    /* Return T */

     return res;
}
\end{verbatim}

You can define as many evaluable functions and actions as you want.
You need to declare them in the kernel, as well as their
external name (as it will appear in the OPs), and the number of arguments
they take. This declaration is made in the body of the
\code{declare\_user\_eval\_funct} function which is called upon start up of
the kernel.

\begin{verbatim}
void declare_user_action(void)
{
     make_and_declare_action("BAR-FOO", action_bar_foo, 2);
     return;
}
\end{verbatim}

\begin{typefn}{Kernel User Function}{void}{make\_and\_declare\_action} 
        {(Function \var{name}, PFPT \var{funct}, int \var{ar})} 
is used to declare an Action.  You have to specify the function name, the C
function which implements it, and the arity of this function.
\end{typefn}

\begin{typefn}{Kernel User Function}{void}{declare\_user\_action} {(void)}
is the function in which you must put your call to
\code{make\_and\_declare\_action}. It is called upon start-up by the kernel and
builds the appropriate table to map the actions and the corresponding C
function.  Note that the user can redefine the predefined actions by using
their name.
\end{typefn}

\section{Graph OP Traversal}
\node{Graph OP Traversal}
\cpindex{Graph OP Traversal}

When a OP is executed, the execution starts at the \code{START} node.
Then it proceeds from one node to an adjacent one if the goal labelling
the edge connecting the two nodes can be achieved. This goes until the
control reach an end node, i.e.\ a node without outgoing edges. If there
are more than one edge outgoing from the current node, the system will
try them one after the other until it findd one it can achieve. Note
however, that there are no a priori predefined path... The system will
try them in a random order. Note also that upon success, untested path
are not kept as possible backtrack point; \CPK{} does not backtrack.

There are split and join nodes (\pxref{Split and Join Node}).  From the graph traversal point of view, these new nodes introduce
parallel execution. A split mode indicates that all the outgoing branches have
to be traversed/executed in their own thread, and a join node indicates that as
many execution threads as there are ingoing branches must reach this node
before execution can proceed from it.


\section{Goal Commitment}
\node{Goal Commitment}
\cpindex{Goal Commitment}

There is a real goal commitment in \COPRS{}. When a goal is posted, it will be
reposted automatically until the system decides that it has been failed.

A goal is failed, when the main loop cannot find any applicable OPs
for this goal. In fact, this is a little bit more tricky. It is when the
main loop cannot find any applicable OP which have not already been tried
with exactly the same binding environment.

If for example you are reaching an edge in the execution of a OP where the goal
\code{G1} has to be achieved. This goal will first be posted, and the system
will look for all the applicable OP for this goal (and possibly other goals or
facts). We shall assume that three OPs are applicable to satisfy this goal. At this
point, either one of these applicable OPs is intended, or none. If none are
intended (presumably because a more important one has been intended), when the
system will resume the execution of the intention in which \code{G1} appeared,
then it will realize that this goal has not been failed (nor has it been
achieved in fact, or by chance by a side effect of other OP execution).
Therefore, it will be reposted, and the applicable OP for this goal will be
recomputed (thus taking into account new changes in the world). Now, we shall
assume then again 3 OPs are applicable and \code{OP1} one of them is chosen.
The system will then try to execute \code{OP1}. If it succeeds, then \code{G1}
is achieved, and the execution of the original OP can resume. If it fails, then
again, when the system will resume the execution of the intention in which
\code{G1} appeared, it will realize that this goal has not been failed. It
will repost the goal G1, however, this time, upon looking for applicable OPs,
and if \code{OP1} is still applicable with exactly the same binding then
previously found, then \code{OP1} will not be put in the applicable OP. In
other words, you do not try the same thing twice, and you consider that a goal
is failed when everything has been tried.

\section{Message Passing}
\node{Message Passing}
\cpindex{Message Passing}

Message passing is the basic communication mechanism in \COPRS{}. It is
very easy to use and provides a simple and powerful mean to communicate
with other \COPRS{} modules or external modules.

\chapter{Parallel Execution of OPs in \COPRS{}}
\node{Parallel Execution of OPs in OPRS}
\cpindex{Parallel Execution of OPs in \COPRS{}}

One can write OPs with parallel execution in various
branches of the OPs. This new feature has a number of consequences on the way
OPs can be executed, and on the performance of the system.



\section{Changes in the OP Representation}
\node{Changes in the OP Representation}
\cpindex{Changes in the OP Representation}

Parallel execution, or conjunctive execution, is represented using split and
join nodes.

\figuregif[scale=0.5]{op-fib}{A OP to compute Fibonacci (without parallelism).}{cha-fib-op}

We illustrate this new construction with concrete examples.  Figure
\ref{cha-fib-op} shows a OP which computes Fibonacci. In this particular case,
the two recursive calls can be done in parallel.

\figuregif[scale=0.5]{op-fib-par}{A OP to compute Fibonacci (with parallelism).}{cha-fib-par-op}

Figure \ref{cha-fib-par-op} shows an example of such construct. In this
particular example we mixed the ``IF-THEN-ELSE'' construction with the split
node. The \code{F} node of the \code{N0} ``IF-THEN-ELSE'' node is a split node
(this is represented with the thick bottom of the node). Similarly, the
\code{S4} node is a join node.  Basically, a split node splits as many threads
as it has outgoing edges, and a join node merges as many thread as it has
ingoing edges.

In this particular example, for each recursive call, we will get two execution
threads. As a consequence, the number of threads active in the system can raise
dramatically. 

Note that if one of the two parallel threads fail, the whole OP fails. This is
the reason why this construct is also called conjunctive execution.

Last, Figure \ref{cha-par-surv-op} presents a OP withdrawn from a mobile robot
execution control application. It shows an example of a procedure implementing
a surveillance. Out from node \code{N3}, two threads are started, one to
execute a trajectory, another one to set a monitoring. If the trajectory
executes properly, it then stops the monitoring task which will return without
modifying the \code{@BILAN} variable.  Otherwise, if the monitoring detects an
obstacle, it returns and the \code{@BILAN} variable is set to nil, which leads
this thread to cancel the trajectory execution.


\figuregif[scale=0.5]{par-surv}{A OP with two threads, one monitoring, the other one executing.}{cha-par-surv-op}

\section{New Traces and New Options}
\node{New Traces and New Options}
\cpindex{New Traces and New Options}

The introduction of parallel execution in OPRS has introduced a number of new
options and trace.

As for the new options, there are two of them (\pxref{OPRS Kernel Run Option Commands}). 

\begin{itemize}

\pgindex{set parallel post (oprs)}
\item \code{set parallel post on|off} Turn on or off the parallel posting of goals.
When this option is \code{ON}, one goal for each thread active in the current
intention will be posted. In the Fibonacci example presented above, it means
that both goals \code{(! (FIBONACCI (- \$N 1) \$RES2))} and \code{(!  (FIBONACCI
(- \$N 2) \$RES3))}, will be posted in parallel.

\pgindex{set parallel intend (oprs)}
\item \code{set parallel intend on|off} Turn on or off the parallel intending of
OP instance. When this option is \code{ON}, all the OP Instances found in the
\code{PREVIOUS\_SOAK} (\pxref{OPRS Kernel Main Loop}) are intended.
\strong{This option has some very important consequences on the standard
behavior of the kernel}. In any case the kernel always checks that a particular
OP Instance has not been already intended before intending it. This is to make
sure, for example, that you do not intend again from a meta level OP, a OP
instance already intended by the main loop or another meta level OP. Moreover,
the kernel always check that a OP Instance intended for a particular goal is
intended in the proper place, i.e.\ it is not intended if there is already
another OP instance which has been intended for the same goal. Note however,
that it may be intended later if it is still applicable and if the other one
has failed.

\pgindex{set parallel intention (oprs)}
\item \code{set parallel intention on|off} Turn on or off the parallel
intention execution.

\end{itemize}

There is also a new trace associated to the new forking/joining mechanism:

\begin{itemize}

\item \code{trace thread on|off} Turn on or off traces on thread creation and
merging.
\pgindex{trace thread (oprs)}

\end{itemize}

\section{Performance Considerations}
\node{Performance Considerations}
\cpindex{Performance Considerations}

The parallel execution of OPs has a number of consequences on the performance of
the system. The positive consequence, is that parallel posting and parallel
intending (\pxref{New Traces and New Options}) can increase the performance as
the main loop does less ``loop'' and therefore some constant overhead of the
main loop is called less time. The drawback, is that the main loop becomes
longer... and the reaction time of the system becomes bigger. The Fibonacci
example is a good example of this behaviors. If you post a goal requesting
a large Fibonacci number, the system will fork a large number of threads, and
will post and intend for each of them.... At some time, you can have hundreds
of threads active, and this can lead to a large reaction time of the system.

\chapter{Meta Level Reasoning}
\node{Meta Level Reasoning}
\cpindex{Meta Level Reasoning}

What is meta level reasoning? By meta level reasoning, we mean all the
mechanisms which enable the user to control various parts or mechanisms of the
\CPK{} main loop. This definition is very large and we will see in this chapter
that it covers many aspects of the \COPRS{} system. The most used meta level
mechanism is probably the one deciding which OP to intend when more than one OP
are applicable. Besides, the meta level reasoning can be used to achieve other
goals while developing a real world application. For example, by controlling
the way OPs are intended, one can use meta level OPs to implement priority
mechanism, or decision theory mechanism, or evidential reasoning, etc. The
field is open, and \COPRS{} provides very powerful mechanisms to implement
advanced reasoning.



\section{SOAK and other Meta Facts}
\node{SOAK and other Meta Facts}
\cpindex{SOAK and other Meta Facts}
\cpindex{SOAK}
\cpindex{APPLICABLE-OPS-FACT}
\cpindex{APPLICABLE-OPS-GOAL}
\cpindex{GOAL-INVOKED-OPS}
\cpindex{FACT-INVOKED-OPS}

SOAK stands for \code{Set Of Applicable OPs}. This fact as well as
\code{APPLICABLE-OPS-FACT}, \code{APPLICABLE-OPS-GOAL},
\code{FACT-INVOKED-OPS} and \code{GOAL-INVOKED-OPS}, are
automatically concluded by the kernel while it computes the current set
of applicable OPs. They are basic event facts (\pxref{Basic Events}),
therefore, they are not ``remembered'' in the database, but can trigger
OPs.

This mechanism is under the control of a flag, that the user can turn on or off
by using the command \code{set meta on|off} (\pxref{OPRS Kernel Meta Level Option Commands}). If it is turned \code{off}, none of theses Meta Facts will be
concluded. If it is turned \code{on}, the individually selected meta facts will
be concluded.

\begin{itemize}

\item
\code{(SOAK list-of-op-instances)}. \code{list-of-op-instances}
contains the \code{LISP\_LIST} of all the op-instances applicable in this loop.
Note that, as shown in the main loop presented in \nxref{OPRS Kernel Main Loop}, the soak is updated at each loop and is not incremented with
the new OP applicable in the current loop. This fact can be used to
trigger Meta OPs which want to decide and sort which OP should be
intended, and which one can be forgotten, or postponed, or whatever you
decide to do with them. Keep in mind that, with meta level reasoning, the
limit of the application is your mind...

The posting of this Meta Fact is under the control of the \code{soak}
option (\pxref{OPRS Kernel Meta Level Option Commands}).

\item
\code{(APPLICABLE-OPS-FACT fact list-of-op-instances)}.
\code{APPLICABLE-OPS-FACT} contains all the OPs applicable (in
\code{list-of-op-instances}) because of the \code{fact}.  \code{fact} is
a \code{TT\_FACT} Term. \code{list-of-op-instances} is a
\code{LISP\_LIST} Term containing OP-Instances. This fact is not
concluded for empty lists of applicable OPs. In other words, if no OP is
applicable because of a fact, then we do not conclude
\code{(APPLICABLE-OPS-FACT fact (. .))}. The reason is left as an
exercise to the reader (hint: if we were to conclude such a fact, we would
blow up the memory space of the system in a few minutes...).

The posting of this Meta Fact is under the control of the \code{app\_ops\_fact}
option (\pxref{OPRS Kernel Meta Level Option Commands}).

\item \code{(APPLICABLE-OPS-GOAL goal list-of-op-instances)}.
\code{APPLICABLE-OPS-GOAL} contains all the OPs applicable (in
\code{list-of-op-instances}) because of the \code{goal}. \code{goal} is a
\code{TT\_GOAL} Term. \code{list-of-op-instances} is a \code{LISP\_LIST}
Term containing the OP-Instances. This fact can be used to sort out which
OP is best suited to fulfill the goal. Due to the goal commitment
(\pxref{Goal Commitment}), it is of little, if no, interest to keep
OPs you have not intended in this list for future use.

The posting of this Meta Fact is under the control of the \code{app\_ops\_goal}
option (\pxref{OPRS Kernel Meta Level Option Commands}).

\item \code{(FACT-INVOKED-OPS fact-invoked-ops)}. This meta fact points at
the list of all the OPs applicable because of a fact (any fact) in the previous
loop.

The posting of this Meta Fact is under the control of the \code{fact\_inv}
option (\pxref{OPRS Kernel Meta Level Option Commands}).

\item \code{(GOAL-INVOKED-OPS goal-invoked-ops)}.  This meta fact points
at the list of all the OPs applicable because of a goal (any goal) in the
previous loop.

The posting of this Meta Fact is under the control of the \code{goal\_inv}
option (\pxref{OPRS Kernel Meta Level Option Commands}).

\end{itemize}

\section{Writing Meta Level OPs}
\node{Writing Meta Level OPs}
\cpindex{Writing Meta Level OPs}
\cpindex{DECISION-PROCEDURE Property}

There is nothing really special about writing Meta Level OPs. They are
standard OPs and nothing particular can distinguish them from other OPs.

However, one often wants the Meta Level OP to be executed ``before''
any other already executing intention. To do so, the \CPK{}
provides the appropriate mechanism. If you put the property
\code{DECISION-PROCEDURE} to \code{T} in the properties list of a OP, this OP,
if intended in a new intention, will be intended as a root of the intention
graph before all the current roots of the intention graph. This will indeed
ensure that this OP gets executed before all the others. Keep in mind, however,
that this does not prevent the execution of this OP from being interrupted...
In other words, if the \CPK{} decides (because of new events) to still intend
new OPs while this OP is executed, it may interrupt the execution of this OP.

At last, let us stress the fact that writing Meta Level OPs is an interesting
and powerful, but dangerous exercise. For example, one can easily see the
consequence of a Meta Level OP which would be applicable to itself... It would
lead the \CPK{} in an infinite loop from which it would never come back, trying
to figure out for ever which OP is applicable, never reaching the fix point of
the recursion (which is to have no OP applicable in one loop, \pxref{OPRS Kernel Main Loop}).

Another more subtle but not less dangerous syndrome is the Meta Level OP which
execution leads to its own applicability... For instance, assume you have a
Meta Level OP which is able to decide what to do when you have two OPs
applicable for the same goal. Now, assume that this very OP posts a goal for
which there are two applicable OPs... Well... You end up with an ever growing
intention graph. At least, in this case, you see the intention graph growing
indefinitely if you graphic trace it.

There are many ways to avoid these pitfalls: most of them consist in
using appropriate properties to guard against oneself, or to only apply to
a set of OPs which have these properties.

\section{Other Aspects of the Meta Level}
\node{Other Aspects of the Meta Level}
\cpindex{Other Aspects of the Meta Level}

As explained earlier, there are other ways to use Meta Level OPs, such as
insuring mutual exclusion on non sharable resources, for example.

\chapter{Advanced Features}
\node{Advanced Features}
\cpindex{Advanced Features}

There are a number of features of \COPRS{} that are considered advanced, in the
sense that they are not required by the ``standard application'' but can be
used by in some particular situations. This chapter describes these features and
explain when they can be used and for which purpose.



\section{OP Properties}
\node{OP Properties}
\cpindex{OP Properties}
\cpindex{Properties in OP}

Properties in OPs are basically information which is linked to the OPs and
their execution environment. Keep in mind that the value of a property can be
any term with evaluable functions and variables. As a result, the value of a
property is a run time value (i.e.\ the value of the property is the value
resulting of its evaluation at the time it is retrieved), and can heavily depend
on the moment at which it is evaluated.

Properties are very much linked to the use of Meta Level OPs. When one writes
Meta Level OPs, one often makes reference to some user-defined properties. Such
properties can be priority, Bayesian information, utility information or even
resources they consume. As for Meta Level reasoning, properties form a general
powerful mechanism which is given to the user to implement any desired control
algorithm or heuristic.

\section{User Hooks}
\node{User Hooks}
\cpindex{User Hooks}
\cpindex{Starting User Hook}
\cpindex{Ending User Hook}

There used to be two user hooks (one at the start of the kernel, another one
upon quitting)  provided to the user to change global variables or to
initialize its own data structure, to initialize library, and symmetrically to
clean up before quitting. Now that the \code{load external} command
(\pxref{OPRS Kernel Miscellaneous Commands}) exists, one can execute any
  arbitrary code upon starting. Still, one can use the
  \code{add\_user\_end\_kernel\_hook} function to add a function to be called before
  quitting the PRS kernel.

\begin{typefn}{Kernel User Function}{void}{add\_user\_end\_kernel\_hook} {(PKV hook)}
is the function which is called to add \code{hook} to the list of functions which
are called by the kernel upon exiting to eventually give a
chance to the user to properly terminate services, close connections, free
global structure or memory, etc. They are executed in the order they are defined.

\end{typefn}

Start kernel hook can still be defined to give a chance to the user to set his
own global value predicate. You can put in it the assignment of
intention\_list\_sort\_predicate to the address of your function.  You can also
change the value of global variables such as \code{main\_loop\_pool\_sec} or
\code{main\_loop\_pool\_usec} (\pxref{Important Variables}).
This hook  can be executed by adding for example in the command file:\\*
\code{load external "user-kernel-hook" "start\_kernel\_user\_hook"}

Example of possible content of the \file{user-kernel-hook.c}:
\begin{verbatim}
void end_kernel_user_hook()
{
     free_my_own_objects();
     shutdown_my_own_server();
}
 
void start_kernel_user_hook()
{
     intention_scheduler = &intention_scheduler_time_sharing;
     main_loop_pool_sec = 0L;
     main_loop_pool_usec = 10000L; /* 10 milliseconds */
     create_my_widget_tree(x_oprs_top_level_widget);
     create_my_own_objects();
     start_my_own_server();
     add_user_end_kernel_hook(end_kernel_user_hook);
}
\end{verbatim}

\section{User Code Error Handler}
\node{User Code Error Handler}
\cpindex{User Code Error Handler}
\cpindex{Error Handler}

There are two functions provided to the user to report fatal or recoverable
error (their prototype is defined in \file{oprs-error\_f-pub.h}). It is strongly
advised to use these functions.

\begin{typefn}{Kernel User Function}{void}{report\_fatal\_external\_error} {(char *error\_message)}
is the function used to report fatal errors. This function does not return
(because the error is considered to be fatal, and terefore the execution cannot
proceed from this point). In other words, it will ``jump'' to a safe place and
try to recover from the error.  According to the current state in which the
error occurs the \CPK{} will take some action to protect the operations still
valid and running in the kernel. Nevertheless, most of the time, such an error
will lead to the failure/cancel of the intention in which it occured.

Many informations are displayed by the kernel on the error itself and the
various operations which resulted of this error. 

The consequence of such fatal error may be so dramatic that you should
not attempt to continue execution. The problem which lead to error should be
fixed first.

Example:
\begin{verbatim}
Term *float_to_int_ef(TermList terms)
{
     Term *res, *t1;

     res = MAKE_OBJECT(Term);

     t1 = (Term *)get_list_pos(terms, 1);

     if (t1->type != FLOAT) {
          report_fatal_external_error("Expecting a FLOAT in float_to_int_ef.");
     }

     res->type = INTEGER;
     res->u.intval = (int)t1->u.doubleval;

     return res;
}
\end{verbatim}
\end{typefn}

\begin{typefn}{Kernel User Function}{void}{report\_recoverable\_external\_error} {(char *error\_message)}
is the function used to report recoverable errors. This function returns, and
the user can then decide what to do, which reasonable value to return, etc.

Here also, many informations are displayed on the screen to provide the user
with valuable hints as where the error occured and in which condition.

Example:
\begin{verbatim}
Term *action_execute_command(TermList terms)
{
     Term *term, *res;

     res = MAKE_OBJECT(Term);
     res->type = ATOM;

     term = (Term *)get_list_pos(terms,1);
     if (term->type != STRING) {
          report_recoverable_external_error("Expecting a STRING in action_execute_command.");
          res->u.id = nil_sym;
     } else {
          PString command;

          command = (char *)OPRS_MALLOC((strlen(term->u.string) + 2) * sizeof(char));
          sprintf(command, "%s\n", term->u.string);
          send_command_to_parser(command);
          OPRS_FREE(command);
          res->u.id = lisp_t_sym;
     }
     return res;
}
\end{verbatim}
\end{typefn}

\section{Intention Graph Scheduling}
\node{Intention Graph Scheduling}
\cpindex{Intention Graph Scheduling}

The \CPK{} provides a mechanism to schedule the root of the intention graph, in
parallel intention execution mode or not. To
do so, the user needs to define his own scheduler functions with the following
prototypes:

\begin{typefn}{Kernel User Function}{Intention\_List}{my\_intention\_list\_scheduler}{(Intention\_List \var{il})}
is the prototype of an intention\_list scheduler. It takes an Intention\_List as
argument and should return one (probably the same). In any case, the first
runnable intention in the returned list will become the current intention.
\end{typefn}

\begin{typevr}{Kernel Variable}{extern PFPL}{intention\_scheduler}
is the global variable which points at the appropriate function used when the
system is not in parallel intention execution. If it is set to NULL, then no
scheduling is used, and the sorting predicate may be used (if set).
\end{typevr}

\begin{typevr}{Kernel Variable}{extern PFPL}{intention\_par\_scheduler}
is the global variable which points at the appropriate function used when the
kernel is in parallel execution mode. If it is set to NULL, then no scheduling
is used, and all the root of the intention graph are executed.
\end{typevr}

Here is an example of how to set the scheduler (withdrawn
from \file{default-user-external.c}):

\begin{verbatim}
void start_kernel_user_hook()
{
     intention_scheduler = &intention_scheduler_time_sharing;
}
\end{verbatim}

Here is an example of a scheduler function, which will schedule a new intention
every 6 times it is called:

\begin{verbatim}
Intention_List intention_scheduler_time_sharing(Intention_List l)
{
     static int loop = 0;

     if (loop++ == 6) {
          Intention *i =  (Intention *)get_from_head(l);
          add_to_tail(l,i);
          loop = 0;
     }
     return l;
}
\end{verbatim}

All these functions and examples are defined in \file{user-external.c}.

\section{Intention Graph Sorting Predicate}
\node{Intention Graph Sorting Predicate}
\cpindex{Intention Graph Sorting Predicate}

The \CPK{} provides a mechanism to ``sort'' the root of the
intention graph under some user specified criteria.

This mechanism is used if and only if no scheduler is defined, and the kernel
is not in parallel intention execution mode. In other words,
\code{intention\_scheduler} has to be set to \code{NULL}, and the \code{Parallel
Intention Execution} flag must be off..

To define a sorting predicate, the user
needs to define his own sorting functions with the following
prototype:

\begin{typefn}{Kernel User Function}{PBoolean}{my\_intention\_list\_sort} {(Intention *\var{i1}, Intention *\var{i2})}
is the prototype of an intention\_list sorting predicates. Note that the
intention root of the graph, which ``maximizes'' this predicate is the one
which will become the current intention.
\end{typefn}

Of course, the name can be changed, but it takes two pointers to an
Intention and returns a PBoolean (\code{TRUE} or \code{FALSE}).

\begin{typevr}{Kernel Variable}{extern PFB}{intention\_list\_sort\_predicate}
is the global variable which points at the appropriate function. If it is set
to NULL, then the list is not sorted at all.
\end{typevr}

Here is an example of how to modify the default sorting predicate (withdrawn
from \file{default-user-external.c}):

\begin{verbatim}
void start_kernel_user_hook()
{
     intention_scheduler = NULL; /* Set it to NULL, or the sorting predicate
                                  * will not be used at all. */
     intention_list_sort_predicate = &my_intention_list_sort;
}
\end{verbatim}

Here is an example of a sorting function, which will sort the intentions
by priority:

\begin{verbatim}
PBoolean my_intention_list_sort_example(Intention *i1, Intention *i2)
{
     return (intention_priority(i1) > intention_priority(i2));
}
\end{verbatim}

Note that, if you want to keep the intention list undisturbed by the sorting
algorithm, when the list is already sorted, then your sorting predicate must
return \code{FALSE} when two intentions are equivalent (in the previous example we use
\code{>} rather than \code{>=}).

All these functions and examples are defined in \file{user-external.c}.

\section{Intending Goals Directly}
\node{Intending Goals Directly}
\cpindex{Intending Goals Directly}

There are more than one way to achieve a goal. The standard mechanism
consists in posting a goal, finding one or more applicable OPs for this
goal.

However, there is at least one other way to intend a more imperative goal. It
is called ``goal intending'' as opposed to the previous method we called
``applicable OP intending''. In the ``goal intending'' method, you directly
intend a new intention which has to achieve a particular goal. The kernel may
discover later that there are no applicable OPs to achieve this goal, but that
will be seen below.

The main difference is that you intend before even knowing if some OPs
will be applicable or not. The ``goal intending'' method is seldom
used, but can be very useful. For instance, one can post parallel goals,
each of them in its own intention by using this technique. An example of
such program is given in the \file{fact-meta.opf} file.

The meta level OP required to perform this goal intending is in the file
\file{meta-intended-goal.opf}. The actions performed are defined in
\nxref{Intending Goal Actions}, and the functions to build these goals are
defined in \nxref{Goal Building Evaluable Functions}.

\section{Current and Quote}
\node{Current and Quote}
\cpindex{Current and Quote}

The \code{current} and \code{quote} mechanism is quite simple. Basically, one
may want to postpone or immediately run the evaluation of some expressions
(presumably in an evaluable function term) in a posted goal.  For example, if
one posts the goal \code{(! (foo (+ 3 4)))}, then the \code{+} operation could
be carried on only when required, presumably when the system checks if it is
true in the database. As long as it is possible, the system could try to
achieve \code{(! (foo (+ 3 4)))}. In this particular case, it does not really
make much difference, because \code{(+ 3 4)} is always \code{7}, independently
of when you are doing it. But let's assume now that we want to achieve a goal
such as \code{(? (> (pressure-of tk1) 245))}, and that the fluent
\code{pressure-of} can return a different value for \code{tk1} according
to the moment at which you ask for the value. Then, obviously the goal \code{(?
(> (pressure-of tk1) 245))} can have a different interpretation according to
the moment at which you post and interpret it\dots{} As said earlier, by
default, now the kernel always evaluates evaluable functions (and their
arguments) at posting time (note that this is a new behavior, and it differs
from SRI's \OPRS{}). But the user can prevent a fluent to be evaluated at the
time the goal is posted.  To do so, one just needs to use the \code{quote}
``function'' (actually, it is not really a function but for this purpose, it
can be considered as one). This \code{quote} function defines a context in
which none of the evaluable functions will be evaluated at posting time, unless
they are embedded in a \code{current} ``function''.

To illustrate this mechanism, we shall consider the following example. If you
want to wait until 6 seconds have elapsed, in the old scheme (or if the
\code{eval\_on\_post} option is \code{off}), you post the goal \code{(\^{} (>=
(time) (+ (current (time)) 6)))}. Because you really want to distinguish
between the call to \code{time} which will be done at ``goal posting'' time,
and the call to \code{time} which is done at ``goal satisfaction'' time.  But
now (by default or if the \code{eval\_on\_post} option is \code{on}) you need to
post: \code{(\^{} (>= (quote (time)) (+ (time) 6)))}.

This mechanism is put under a flag control, that the user can set on or off
using the command \code{set eval post on|off} (\pxref{OPRS Kernel Run Option Commands}). As said earlier, the new default behavior is to always
evaluate the evaluable functions in a posted goal.

If this flag is set to \code{off}, the evaluation is done when required by the
database, or when a \code{current} is used. One drawback of this approach (and
this is the reason why the default mechanism is to evaluate every evaluable
functions) is that it forces the user to use \code{current} whenever he wants
to force an evaluation. For example, if you program factorial without using
\code{current}, the real computation (the n - 1 multiplication) may be
delayed until ``printing'' or until you affect the value to some variable (the
\code{=} OP does an explicit \code{current} on its second argument). Another
drawback, is that evaluable functions can then be evaluated more than once...
If this evaluable function runs with considerable overhead, this my lead to very
poor performance.

If it is set to \code{on}, which is its default value, any evaluable function
would by default be evaluated at goal posting time, unless it is in the quote
function. To keep the same semantics, the goal \code{(\^{} (>= (time) (+ (current
(time)) 6)))} would then become: \code{(\^{} (>= (quote (time)) (+ (time) 6)))}.

\section{Critical Section}
\node{Critical Section}
\cpindex{Critical Section}

A critical section mechanism is provided in \COPRS{}. Its use is very simple but
should be reserved to very short sequences of goal execution, for which mutual
exclusion is required (to allocate resources, for example).

During the critical section, the current intention and the current thread
cannot be changed, and remains the same. Moreover, external events are not
parsed (they are kept in the input buffer though), and meta level facts are not
concluded. However, facts and goals posted by the current thread are taken into
account.

A number of situations will break the critical section, i.e.\ they will force the
kernel to exit the critical section state. This will happen if the thread in
critical section joins (and it is not the last thread to join). Similarly, if
you perform active maintenance in a critical section, the system will break it.
You may also get warning if you are doing suspicious things such as spliting in
a critical section...

Critical sections are not re-entrant, thus, it is forbidden to open a new
critical section while you are already in one (there is little interest in
doing so). Keep in mind that while the kernel is in a critical section,
external events are not parsed, and the reaction time of the system is
therefore increased.

To start and end a critical section, use the \code{start-critical-section} and
the \code{end-critical-section} action. Corresponding OPs are provided in
\file{new-default.opf}.

\section{Universal Quantification of Variables}
\node{Universal Quantification of Variables}
\cpindex{Universal Quantification of Variables}

Universal quantification of variables can be obtained by using the \code{all},
\code{n-all} and \code{n-all-list} functions (\pxref{Lisp Evaluable Functions}).

These functions return lists of binding which universally quantify some variables.

\section{User Pointers}
\node{User Pointers}
\cpindex{User Pointers}

It is possible for a user to define its own data structure to manipulate and to
be manipulated by the kernel. For example, one can define a robot path as a
particular C data structure, which can then be manipulated by its pointer.
Appropriate actions, evaluable functions and evaluable predicates can then
respectively be used to create this objects, to access slots or test properties
of this object. One issue arising of this facility is to determine which
objects should be manipulated as user-defined objects (which are thus opaque to
the kernel) and which objects should be represented explicitly in the database.
This trade off is a readability/efficiency/accessibility issue. For example,
the information hidden in user-defined objects cannot be easily used to trigger
procedure execution.

\section{Action Slicing}
\node{Action Slicing}
\cpindex{Action Slicing}

Long user-defined actions can be time sliced. By returning a special token
\code{:wait}, they are not considered by the kernel as completed and will be
called again to finish their duties. An action can be time sliced in as many
parts as the user decides when it programs it. For example, if it writes an
action which perform some long computation such as writing a collection of data
in a file, it may decides to write one object at a time and to call it as many
time as there are objects. Keep in mind that the reactivity of the application
depends of the longest action/evaluable functions of your application.
Therefore, to increase the reactivity of your kernel, you may have to time
slice the execution of actions.

See \code{action\_first\_call} and \code{action\_number} (\pxref{Intention Manipulation Functions}).

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "oprs"
%%% TeX-PDF-mode: t
%%% End: 
